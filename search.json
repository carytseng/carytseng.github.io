[{"title":"CAP定理","url":"/2020/11/04/CAP定理/","content":"\n> 面试被问到CAP定理，之前看过，真正问起来讲得不清楚，估计没有真正的理解这个定理，故作此文进行记录\n\n分布式系统有三个指标，也即一致性、可用性、分区容错\n\n（C）一致性：多个节点的数据保持一致，当某个节点的数据修改后，需要同步修改所有节点的数据，保持一致\n\n（A）可用性：即当某个节点宕机后，整个集群还能正常对外服务，保证服务健康\n\n（P）分区容错：两个节点间可能会无法通信，P定理总是成立的。\n\n一致性和可用性不可能同时成立，因为P即分区容错总是可能出现，如果要保证一致性，则必须保证所有节点都收到该数据的同步，才能对外服务，这就不满足可用性。如果满足可用性，即某个节点崩坏了也要提供服务，那么就不能保证一致性。\n\n所以一般需要根据业务需要，保证C或A其中一个特性，例如网页更新可以采取可用性，因为最终用户都会看到最新的版本；如果是银行等金融数据，需要保证强一致性，则需要抛弃可用性。\n\n"},{"title":"栈实现队列","url":"/2020/10/28/栈实现队列/","content":"\n相对好理解的一条题目，栈的特点是后进先出，队列的特点是先进先出，那么用两个栈怎么实现队列呢？设S1和S2两个栈，要实现先进先出，如果都放到一个栈中，栈底元素是最先入的，那么要先出，得把栈底元素变成栈顶元素，这时候就利用到第二个栈了，把S1的元素都倒到S2，那么S2的栈顶元素就是最先入栈的，也就符合队列的特性。\n\n入队列思路\n\n* 直接放入S1\n\n出队列思路\n\n* 判断S2是否为空，空则将S1的数据倒到S2，不为空不处理，S2弹出栈顶元素。这里直接保证了当出栈时，S2只要有元素，则一直弹，否则再从S1中取数据，减少了倒来倒去的过程\n\n```java\nclass QueueSample{\n  Stack<Integer> s1=new Stack();\n  Stack<Integer> s2=new Stack();\n  \n  public void push(int x){\n    s1.push(x);\n  }\n  \n  public int pull(){\n    if(s2.isEmpty()){\n      while(!s1.isEmpty()){\n        s2.push(s1.pop());\n      }\n    }\n    return s2.pop();\n  }\n  \n  public boolean isEmpty(){\n\t\treturn s1.isEmpty()&&s2.isEmpty();\n  }\n}\n```\n\n"},{"title":"Redis探究","url":"/2020/10/28/Redis探究/","content":"\n> 工作中接触Redis大多仅用来作为缓存，也用过来做分布式锁，对于内部的实现机制及高级用法几乎是走马观花，故作此文用来记录相关的知识点，从原理出发慢慢拓展此文，全部用自己的理解话术来进行记录，个人理解，有误请指出。\n\n## Redis\n\nRedis诞生之初是为了解决关系型数据库的性能问题，由于IO需要对磁盘的读写速度满足不了实际场景，因此创造者利用内存造了一个内存数据库，没有关系型数据库的约束，Redis提供的数据结构简单且能满足高性能的读写场景，其基于对内存的读写，能够在短时间内处理数据，由于读写速度快，免去IO的局限，IO涉及操作系统用户空间与内核空间的数据复制及事件等待，所以redis采用单线程的处理模型，免去线程切换的开销，因为也没必要进行多线程处理\n\n### 对比memcached\n\n支持多种数据结构，memcached仅支持字符串且不支持持久化\n\n## 请求处理\n\nRedis采用基于Reactor模式开发网络事件处理器，采用IO多路复用技术，简单来说就是一条线程监听多个客户端socket，当有事件到时，将事件作为一个task放到队列中，接下来文件处理器会对队列中的task进行处理，文件处理器是单线程的，没有线程的切换问题，文件处理器包含连接应答器、命令请求处理器、命令回复处理器，执行相应的命令后，返回相应。这也是Redis速度快的原因：IO多路复用、单线程处理task、基于内存的数据操作\n\n![timg](/assets/blog_img/timg.jpeg)\n\n## Redis数据结构\n\n基于键值的存储，值支持以下几种类型\n\n* string：字符串\n  * 字节串：非字符自增会报错\n  * 整数：可自增减\n  * 浮点数\n* list：有序队列\n  * 可用作队列\n* set：集合\n* hash：散列\n* zset：有序集合\n  * 相比散列，提供基于分值的相关功能，每个key有对应的score，应对一些场景应用\n\n## 持久化\n\nRedis提供持久化的功能，能够将内存的数据定时写入硬盘，保证数据在系统重启后能够恢复，继续进行服务\n\n两种持久化的方式：\n\n* 快照\n* AOF\n\n### 快照\n\n　　快照：会开启一个子进程定时对内存的数据进行打快照，使用BGSAVE命令，缺点是快照是按周期打，性能有限，一旦系统崩溃，会丢失从上次快照之后的数据，也有可能在刚打完快照就崩溃。而且打快照可能会造成Redis停顿\n\n### AOF\n\n　　AOF：将Redis的执行命令记录下来，记录到AOF文件中，可根据需要设置频率，恢复时只需要执行相应的写命令即可。缺点是AOF的文件会随着内存数据的增大而增大，造成磁盘爆满，可以使用命令对AOF文件重写，压缩冗余的部分\n\n同步频率\n\n* always：每个命令都写入磁盘\n\n* everysec：每秒同步一次，多个命令到磁盘\n\n* no：由系统决定写入时间\n\n### 复制\n\n水平添加多个Redis实例，通过主从服务器来满足高性能的读写请求。主服务器将快照文件发送到从服务器，从服务器获得快照并初始化数据\n\n### 过期时间设置\n\nRedis提供过期时间设置保证内存空间，也能保证热数据\n\nRedis后台有两种方式对过期数据进行删除\n\n* 定期删除：每隔一段时间抽取过期的key然后删除\n* 惰性删除：当系统查询到这个过期key时会删除\n\n### 热key问题\n\n针对某个key的大流量请求，造成物理机的网卡超载，导致Redis宕机引发雪崩\n\n解决思路：\n\n* 提前把key打到不同的服务器\n* 加入二级缓存，提前加载热key到内存\n\n### 缓存击穿|缓存穿透|缓存雪崩\n\n#### 缓存击穿\n\n类似热key问题，区别点在于key的过期导致请求打在DB上\n\n解决思路：\n\n* 加锁更新，对key进行加锁，在数据库查询前就进行了拦截\n* 过期时间写在value中，用异步方式刷新过期时间\n\n#### 缓存穿透\n\n查询缓存中不存在的key，恶意请求大量制造不存在的key直接请求DB\n\n解决思路：\n\n* 加一层布隆过滤器\n\n#### 缓存雪崩\n\n某一时刻可能发生大规模的缓存失效，例如缓存服务宕机，大量的key同时失效，请求打到DB，导致整个系统雪崩\n\n* 不同的key设置不同的过期时间，避免同时过期\n* 限流，降低db压力\n* 二级缓存\n\n\n\n\n\n","tags":["Nosql"]},{"title":"Spring多数据源加载","url":"/2020/10/07/Spring多数据源加载/","content":"\n### 前言\n\n> Spring引入多数据源的方式，系统扩展的过程中可能会引入多个数据源，查阅了一些博客，发现引入方式或多或少都需要引入新的配置类，这里记录下在不需要修改任何代码的情况下，扩展数据源的方式，以后只需要在配置文件添加配置就能直接引入。\n\n### 引入方式\n\n* 分包方式\n* 参数化方式\n* 注解+AOP\n\n#### 分包方式\n\n比较简单，哪个数据源的操作就走哪个mapper目录下的文件，一般就是两个库无任何关联的场景。\n\n#### 参数化方式\n\n根据传入的参数选择数据源，进行数据查询，个人比较推崇这一种方式。\n\n#### 注解+AOP\n\n在特定的方式上添加自定义的注解，配置上需要选择的数据源值，AOP执行的时候通过获取注解上的值来切换，这种方式需要在方法上写死需要的数据源，不太灵活。\n\n### 引入数据源的思路\n\n* 配置文件添加多个数据源\n* 自定义数据源配置\n* 注入Spring容器\n* 利用ThreadLocal的上下文，实现线程与数据源的绑定关系\n* 使用上用参数化还是AOP等都可以\n\n### 步骤\n\napplication.yml\n\n```yml\nspring:\n  datasource:\n    master:\n      password: 12345678\n      jdbcUrl: jdbc:mysql://127.0.0.1:3306/master?useUnicode=true&characterEncoding=UTF-8\n      driverClassName: com.mysql.jdbc.Driver\n      username: root\n    slave1:\n      password: 12345678\n      jdbcUrl: jdbc:mysql://127.0.0.1:3306/slave1?useUnicode=true&characterEncoding=UTF-8\n      driverClassName: com.mysql.jdbc.Driver\n      username: root\n    slave2:\n      password: 12345678\n      jdbcUrl: jdbc:mysql://127.0.0.1:3306/slave2?useUnicode=true&characterEncoding=UTF-8\n      driverClassName: com.mysql.jdbc.Driver\n      username: root\n```\n\n建立一个property类来映射配置，这样我们就能拿到多个数据源的配置了。\n\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"spring\")\npublic class DynamicDataSourceProperty {\n  \t//只映射datasource\n    private Map<String, Object> datasource;\n}\n```\n\n接下来我们就是将所有的配置转换成bean并且注入到Spring中。\n\n```java\n@Configuration\n@MapperScan(basePackages = \"com.demo.sv.mapper\")\npublic class DynamicDataSourceConfig {\n    @Autowired\n    private BeanFactory beanFactory;\n    @Autowired\n    private DynamicDataSourceProperty dynamicDataSourceProperty;\n\n    /**\n     * 功能描述: <br>\n     * 〈动态数据源bean 自动配置注册所有数据源〉\n     *\n     */\n    @Bean\n    @Primary\n    public DataSource dynamicDataSource() {\n      \t//拿到Spring容器\n        DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory;        \n        /*获取yml所有数据源配置*/\n        Map<String, Object> datasource = dynamicDataSourceProperty.getDatasource();\n        Map<Object, Object> dataSourceMap = new HashMap<>(5);\n        Optional.ofNullable(datasource).ifPresent(map -> {\n            for (Map.Entry<String, Object> entry : map.entrySet()) {\n                //创建数据源对象\n                HikariDataSource dataSource = (HikariDataSource) DataSourceBuilder.create().build();\n                String dataSourceId = entry.getKey();\n                configeDataSource(entry, dataSource);\n                /*bean工厂注册每个数据源bean*/\n                listableBeanFactory.registerSingleton(dataSourceId, dataSource);\n                dataSourceMap.put(dataSourceId, dataSource);\n            }\n        });\n        //AbstractRoutingDataSource设置主从数据源\n        return new DynamicDataSource(beanFactory.getBean(\"master\", DataSource.class), dataSourceMap);\n    }\n\t\t\n  \t//从配置转换成bean\n    private void configeDataSource(Map.Entry<String, Object> entry, HikariDataSource dataSource) {\n        Map<String, Object> dataSourceConfig = (Map<String, Object>) entry.getValue();\n        dataSource.setJdbcUrl(MapUtils.getString(dataSourceConfig, \"jdbcUrl\"));\n        dataSource.setDriverClassName(MapUtils.getString(dataSourceConfig, \"driverClassName\"));\n        dataSource.setUsername(MapUtils.getString(dataSourceConfig, \"username\"));\n        dataSource.setPassword(MapUtils.getString(dataSourceConfig, \"password\"));\n    }\n}\n```\n\n切换数据源我们需要用到Spring提供的一个抽象类AbstractRoutingDataSource，这个类有个抽象方法determineTargetDataSource，我们通过继承这个类，并且实现determineTargetDataSource方法，这个determineTargetDataSource就是决定调用数据源的逻辑，简单来说这个方法算出key值，然后去数据源池取出我们需要的数据源。\n\n```java\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    public DynamicDataSource(DataSource defaultDataSource, Map<Object, Object> targetDataSource) {\n        backupTargetDataSources = targetDataSource;\n        super.setDefaultTargetDataSource(defaultDataSource);\n        super.setTargetDataSources(backupTargetDataSources);\n        super.afterPropertiesSet();\n    }\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.info(\"当前的数据源：{}\",DynamicDataSourceContextHolder.getContextKey());\n      \t//我们自己定义了一个DynamicDataSourceContextHolder来维护key，只要我们在方法调用前设置key，Spring会根据这个方法来决定数据源\n        return DynamicDataSourceContextHolder.getContextKey();\n    }\n}\n```\n\n测试类，Springboot项目要加入排除自动配置数据源注解@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n\n```java\n@SpringBootTest\n@RunWith(SpringJUnit4ClassRunner.class)\nclass SvApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private ApplicationContext context;\n\n    @Test\n    public void query() {\n        User user = new User();\n      \t//根据需要切换我们需要的数据源\n        DynamicDataSourceContextHolder.setContextKey(\"slave2\");\n        List<User> users= userMapper.query();\n        DynamicDataSourceContextHolder.remove();\n        System.out.println(users);\n    }\n\n}\n```\n\n### 关于多数据源的事务处理\n\n当引入多数据源后，如果要加入事务处理，同一个事务中处理处理两个数据源的数据会失败，主要是因为第一个数据源打开数据库连接后，会加入ThreadLocal中与线程进行绑定，而此时第二个数据源再获取sqlSession，发现不为空，取的是第一个数据源的连接，所以会有问题。如果要支持，思路就是保证sqlSession的独立，但不能保证分布式事务的正确处理。查阅相关资料，可以使用XA协议，具体此文没有详细探讨。","tags":["技术学习","数据源"]},{"title":"从零开始写框架-SpringMVC","url":"/2020/09/30/从零开始写框架-SpringMVC/","content":"\n> 前言：\n>\n> 　　最近打算提升下源码能力，跟着相关教程实现Spring框架，巩固下前面的学习知识，像反射、设计模式等，顺带熟悉一些API。像设计模式这类知识，只能通过代码实践来提升对其核心思想的理解，毕竟设计模式不是凭空产生的，而是在代码实践的过程中，通过不断地重构提炼，发现其奥妙之处，才产生相关的程序思想。\n\n### 1.0 MVC\n\n#### 准备工作\n\n#### 配置文件application.properties\n\n```xml\nscanPackage=com.gupaoedu.demo\n```\n\n#### 自定义注解\n\n这部分主要模拟Spring中我们常用的Autowired，Controller，RequestMapping，RequestParam，Service等。\n\n注解文件：\n\n```java\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface GPAutowired {\n    String value() default \"\";\n}\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface GPController {\n    String value() default \"\";\n}\n\n@Target({ElementType.TYPE,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface GPRequestMapping {\n    String value() default \"\";\n}\n\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface GPRequestParam {\n    String value() default \"\";\n}\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface GPService {\n    String value() default \"\";\n}\n```\n\nweb.xml文件：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <servlet>\n        <servlet-name>gpmvc</servlet-name>\n        <servlet-class>com.gupaoedu.mvcframework.v1.servlet.GPDispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>application.properties</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>gpmvc</servlet-name>\n        <url-pattern>/*</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\nController类：\n\n```java\n@GPController\n@GPRequestMapping(\"/demo\")\npublic class DemoAction {\n\n    @GPAutowired\n    private IDemoService demoService;\n\n    @GPRequestMapping(\"/query\")\n    public void query(HttpServletRequest req, HttpServletResponse resp, @GPRequestParam(\"name\") String name){\n        String result = demoService.get(name);\n        try{\n            resp.getWriter().write(result);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    @GPRequestMapping(\"/add\")\n    public void add(HttpServletRequest req,HttpServletResponse resp,@GPRequestParam(\"a\")Integer a,@GPRequestParam(\"b\") Integer b){\n        try{\n            resp.getWriter().write(a+\"+\"+b+\"=\"+(a+b));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    @GPRequestMapping(\"/remove\")\n    public void remove(HttpServletRequest req,HttpServletResponse resp,@GPRequestParam(\"a\")Integer a,@GPRequestParam(\"b\") Integer b){\n\n    }\n}\n```\n\nService接口：\n\n```java\npublic interface IDemoService {\n    public String get(String name);\n}\n```\n\nService实现类：\n\n```java\n@GPService\npublic class DemoService implements IDemoService {\n    @Override\n    public String get(String name) {\n        return \"my name is \" + name;\n    }\n}\n```\n\n#### 核心思路：\n\n思路：首先我们要实现SpringMVC，思考下需要什么组件，第一肯定是IOC容器，暂时可以使用Map来代替。还有就是能通过url来找controller的这么一个路由器，我们也可以用一个Map来存。上面的注解是标记文件的，我们需要扫描这部分标记有注解的文件，我们需要利用反射初始化相关类的实例，放到Map中，并且我们还要实现属性注入功能。\n\n初始化中我们需要做以下工作：\n\n* 扫描配置文件\n* 通过项目路径将注解相关的类，通过反射实例化\n* 实现类中的属性注入功能\n* 实现url与handler的映射，也即路由。\n\n```java\npublic class GPDispatcherServlet extends HttpServlet {\n    private Map<String, Object> mapping = new HashMap<String, Object>();\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try {\n            doDispatch(req, resp);\n        } catch (Exception e) {\n            e.printStackTrace();\n            resp.getWriter().write(\"500 error\");\n        }\n    }\n\n    private void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws IOException, InvocationTargetException, IllegalAccessException {\n        //获取请求url\n        String url = req.getRequestURI();\n        String contextPath = req.getContextPath();\n        url = url.replace(contextPath, \"\").replaceAll(\"/+\", \"\");\n        if (!this.mapping.containsKey(url)) {\n            resp.getWriter().write(\"404....\");\n        }\n        Method method = (Method) this.mapping.get(url);\n        Map<String, String[]> params = req.getParameterMap();\n        method.invoke(this.mapping.get(method.getDeclaringClass().getName()), new Object[]{req, resp, params.get(\"name\")[0]});\n    }\n\n  \t//简易版本实现全部在一个方法中\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        InputStream is = null;\n        try {\n            Properties configContext = new Properties();\n            is = this.getClass().getClassLoader().getResourceAsStream(config.getInitParameter(\"contextConfigLocation\")); \n          \t//读取配置文件\n            configContext.load(is);\n            String scanPackage = configContext.getProperty(\"scanPackage\");\n            //扫描配置路径下的类\n            doScanner(scanPackage);\n          \t//实例化标有注解的类\n            for (String className : mapping.keySet()) {\n                if (!className.contains(\".\")) {\n                    continue;\n                }\n                Class<?> clazz = Class.forName(className);\n                if (clazz.isAnnotationPresent(GPController.class)) {\n                    mapping.put(className, clazz.newInstance());\n                    String baseUrl = \"\";\n                    if (clazz.isAnnotationPresent(GPRequestMapping.class)) {\n                        GPRequestMapping requestMapping = clazz.getAnnotation(GPRequestMapping.class);\n                        baseUrl = requestMapping.value();\n                    }\n                    Method[] methods = clazz.getMethods();\n                    for (Method method : methods) {\n                        if (!method.isAnnotationPresent(GPRequestMapping.class)) {\n                            continue;\n                        }\n                        GPRequestMapping requestMapping = method.getAnnotation(GPRequestMapping.class);\n                        String url = (baseUrl + \"/\" + requestMapping.value()).replaceAll(\"/+\", \"/\");\n                        mapping.put(url, method);\n                        System.out.println(\"Mapped \" + url + \",\" + method);\n                    }\n                } else if (clazz.isAnnotationPresent(GPService.class)) {\n                    GPService service = clazz.getAnnotation(GPService.class);\n                    String beanName = service.value();\n                    if (\"\".equals(beanName)) {\n                        beanName = clazz.getName();\n                    }\n                    Object instance = clazz.newInstance();\n                    mapping.put(beanName, instance);\n                    for (Class<?> i : clazz.getInterfaces()) {\n                        mapping.put(i.getName(), instance);\n                        System.out.println(i.getName());\n                    }\n                } else {\n                    continue;\n                }\n            }\n            //进行类的属性注入\n            for (Object object : mapping.values()) {\n                if (object == null) {\n                    continue;\n                }\n                Class clazz = object.getClass();\n                if (clazz.isAnnotationPresent(GPController.class)) {\n                    Field[] fileds = clazz.getDeclaredFields();\n                    for (Field field : fileds) {\n                        if (!field.isAnnotationPresent(GPAutowired.class)) {\n                            continue;\n                        }\n                        GPAutowired autowired = field.getAnnotation(GPAutowired.class);\n                        String beanName = autowired.value();\n                        if (\"\".equals(beanName)) {\n                            beanName = field.getType().getName();\n                        }\n                        field.setAccessible(true);\n                        //对象的属性设置为value\n                        field.set(mapping.get(clazz.getName()), mapping.get(beanName));\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        System.out.println(\"GP mvc init...\");\n\n    }\n\n  \t//扫描所有的类\n    private void doScanner(String scanPackage) {\n        URL url = this.getClass().getClassLoader().getResource(\"/\" + scanPackage.replaceAll(\"\\\\.\", \"/\"));\n        File classDir = new File(url.getFile());\n        for (File file : classDir.listFiles()) {\n            if (file.isDirectory()) {\n                doScanner(scanPackage + \".\" + file.getName());\n            } else {\n                if (!file.getName().endsWith(\".class\")) {\n                    continue;\n                }\n                String clazzName = (scanPackage + \".\" + file.getName().replace(\".class\", \"\"));\n                mapping.put(clazzName, null);\n            }\n        }\n    }\n}\n```\n\n### 2.0 MVC\n\n1.0版本将所有的代码逻辑都写在init方法内，我们需要将相关的步骤抽取出来，进行优化\n\n#### init方法\n\n```java\npublic void init(ServletConfig config) throws ServletException {\n\t\t//加载配置文件\n    doLoadConfig(config.getInitParameter(\"contextConfigLocation\"));\n\t\t//扫描类\n    doScanner(contextConfig.getProperty(\"scanPackage\"));\n\t\t//反射实例化类\n    doInstance();\n\t\t//注入\n    doAutowired();\n\t\t//初始化url与方法映射关系\n    initHandlerMapping();\n\n    System.out.println(\"GP mvc init...\");\n\n}\n```\n\n#### doLoadConfig方法\n\n```java\nprivate void doLoadConfig(String contextConfigLocation) {\n    InputStream is = null;\n    try {\n        is = this.getClass().getClassLoader().getResourceAsStream(contextConfigLocation);\n        contextConfig.load(is);\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (null != is) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### doScanner方法\n\n递归扫描所有类，将扫描到的类到放到List中，后面需要进行实例化。\n\n```java\nprivate void doScanner(String scanPackage) {\n    URL url = this.getClass().getClassLoader().getResource(\"/\" + scanPackage.replaceAll(\"\\\\.\", \"/\"));\n    File classDir = new File(url.getFile());\n    for (File file : classDir.listFiles()) {\n        if (file.isDirectory()) {\n            doScanner(scanPackage + \".\" + file.getName());\n        } else {\n            if (!file.getName().endsWith(\".class\")) {\n                continue;\n            }\n            String clazzName = (scanPackage + \".\" + file.getName().replace(\".class\", \"\"));\n            classNames.add(clazzName);\n        }\n    }\n}\n```\n\n#### doInstance方法\n\n实例化Bean，模拟将实例化的Bean放进IOC中，我们用一个Map来代替。\n\n```java\nprivate void doInstance() {\n    if (classNames.isEmpty()) {\n        return;\n    }\n    try {\n        for (String className : classNames) {\n            Class<?> clazz = Class.forName(className);\n\n            if (clazz.isAnnotationPresent(GPController.class)) {\n                Object instance = clazz.newInstance();\n                String beanName = toLowerFirstCase(clazz.getSimpleName());\n                ioc.put(beanName, instance);\n            } else if (clazz.isAnnotationPresent(GPService.class)) {\n                GPService service = clazz.getAnnotation(GPService.class);\n                String beanName = service.value();\n                if (\"\".equals(beanName)) {\n                    beanName = toLowerFirstCase(clazz.getSimpleName());\n                }\n\n                Object instance = clazz.newInstance();\n                ioc.put(beanName, instance);\n                for (Class<?> i : clazz.getInterfaces()) {\n                    if (ioc.containsKey(i.getName())) {\n                        throw new Exception(\"the \" + i.getName() + \" is exists\");\n                    }\n                    ioc.put(i.getName(), instance);\n                }\n            } else {\n                continue;\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n#### doAutowired方法进行注入\n\n这一步我们将容器内的类取出来，通过反射将属性给拿到，通过扫描注解，再从容器中拿到相关的Bean然后注入到当前类的属性中。\n\n```java\nprivate void doAutowired() {\n    if (ioc.isEmpty()) {\n        return;\n    }\n    for (Map.Entry<String, Object> entry : ioc.entrySet()) {\n        //取出所有的属性\n        Field[] fields = entry.getValue().getClass().getDeclaredFields();\n        for (Field field : fields) {\n            if (!field.isAnnotationPresent(GPAutowired.class)) {\n                continue;\n            }\n            GPAutowired autowired = field.getAnnotation(GPAutowired.class);\n            String beanName = autowired.value().trim();\n            if (\"\".equals(beanName)) {\n                beanName = field.getType().getName();\n            }\n\n            field.setAccessible(true);\n            try {\n                field.set(entry.getValue(), ioc.get(beanName));\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### initHandlerMapping方法\n\n这一步我们将所有Controller的方法拿到，并且拿到对应的url相对路径，并且将url与处理方法映射给保存起来，在请求路由的时候就根据url来找到相应的方法，通过反射执行对应方法。\n\n```java\nprivate void initHandlerMapping() {\n    if (ioc.isEmpty()) {\n        return;\n    }\n\n    for (Map.Entry<String, Object> entry : ioc.entrySet()) {\n        Class<?> clazz = entry.getValue().getClass();\n\n        if (!clazz.isAnnotationPresent(GPController.class)) {\n            continue;\n        }\n\n        String baseUrl = \"\";\n        if (clazz.isAnnotationPresent(GPRequestMapping.class)) {\n            GPRequestMapping gpRequestMapping = clazz.getAnnotation(GPRequestMapping.class);\n            baseUrl = gpRequestMapping.value();\n        }\n\n        for (Method method : clazz.getMethods()) {\n            if (!method.isAnnotationPresent(GPRequestMapping.class)) {\n                continue;\n            }\n\n            GPRequestMapping gpRequestMapping = method.getAnnotation(GPRequestMapping.class);\n\n            String url = (\"/\" + baseUrl + \"/\" + gpRequestMapping.value()).replaceAll(\"/+\", \"/\");\n\n            handlerMapping.put(url, method);\n        }\n\n    }\n}\n```\n\n#### doDispatch路由逻辑\n\n请求路由逻辑，思路是这样的，拿到请求url，通过url找到初始化的method，这时候就有了目标类的执行方法。接下来就是填充请求参数，填充完后执行method.invoke方法执行目标类的方法，完成请求。\n\n```java\nprivate void doDispatch(HttpServletRequest req, HttpServletResponse resp) throws IOException, InvocationTargetException, IllegalAccessException {\n    String url = req.getRequestURI();\n    String contextPath = req.getContextPath();\n    url = url.replace(contextPath, \"\").replaceAll(\"//+\", \"/\");\n    if (!this.handlerMapping.containsKey(url)) {\n        resp.getWriter().write(\"404....!\");\n    }\n  \t//拿到url对应的controller请求方法\n    Method method = (Method) this.handlerMapping.get(url);\n    //请求传进来的实参\n    Map<String, String[]> parameterMap = req.getParameterMap();\n    //取到形参类型\n    Class<?>[] parameterTypes = method.getParameterTypes();\n\t\t//实参数组初始化\n    Object[] paramValues = new Object[parameterTypes.length];\n\t\t//这里只处理String类型\n    for (int i = 0; i < parameterTypes.length; i++) {\n        Class paramterType = parameterTypes[i];\n        if (paramterType == HttpServletRequest.class) {\n            paramValues[i] = req;\n            continue;\n        } else if (paramterType == HttpServletResponse.class) {\n            paramValues[i] = resp;\n            continue;\n        } else if (paramterType == String.class) {\n            Annotation[][] pa = method.getParameterAnnotations();\n            for (int j = 0; j < pa.length; j++) {\n                for (Annotation a : pa[i]) {\n                    if (a instanceof GPRequestParam) {\n                        String paramName = ((GPRequestParam) a).value();\n                        if (!\"\".equals(paramName.trim())) {\n                            String value = Arrays.toString(parameterMap.get(paramName)).replaceAll(\"\\\\[|\\\\]\", \"\").replaceAll(\"\\\\s\", \",\");\n                            paramValues[i] = value;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    String beanName = toLowerFirstCase(method.getDeclaringClass().getSimpleName());\n    method.invoke(this.ioc.get(beanName), paramValues);\n    System.out.println(method);\n}\n```\n\n### 3.0 MVC\n\n待更\n\n","tags":["技术学习","Spring","从零开始写框架"]},{"title":"读书笔记系列-黄帝内经","url":"/2020/09/25/读书笔记系列-黄帝内经/"},{"title":"新入书单","url":"/2020/09/25/新入书单/","content":"\n* Google工作法\n* 图解黄帝内经\n* 我们内心的冲突\n* 我们时代的神经症人格\n* Spring5核心原理与30个类手写实战\n* 零基础学炒股从入门到精通\n\n***\n\n**待购入**\n\n* 价值：我对投资的思考\n* 墨菲定律\n* 李大霄投资战略\n* 聪明的投资者"},{"title":"GC垃圾收集器","url":"/2020/09/15/GC垃圾收集/","content":"\n# GC垃圾收集\n\nJVM针对堆中的对象，启用守护线程进行无用对象的回收，防止JVM的内存溢出造成程序不可用。\n\n## 判断可否回收\n\n* 引用计数法\n\n  简单来讲就是判断对象是否存在引用，没有则认为可回收，但若存在循环引用的情况，就无法判断导致内存泄漏\n\n* 可达性分析\n\n  通过GC Roots对象作为起点进行搜索，如果一个对象与GC Roots之前没有可达路径，则认为该对象不可达，但还需要经过两次标记才能进行回收\n\n## 强、软、弱、虚引用\n\n强引用：存在引用的对象就是强引用对象，gc即使溢出都不会收集这类对象\n\n软引用：SoftReference对象，如果gc快溢出了，会收集这类对象\n\n弱引用：WeakReference对象，不管gc空间是否足够都会回收\n\n虚引用：主要用来跟踪垃圾回收器的活动\n\n## 垃圾收集算法\n\n* 复制算法\n  * 对内存分区，创建放一边，回收时存活的复制到另一边，然后对原来的空间直接清除。缺点是空间利用率不高，改进可按一定比例划分空间\n* 标记清除算法\n  * 垃圾的对象标记起来，然后清除垃圾对象。缺点是容易产生内存碎片，导致大对象创建时，发生多次gc\n* 标记整理算法\n  * 复制算法与标记清除算法的折中策略，标记垃圾对象，将存活的对象复制到边端，然后清除垃圾对象。\n\n## 商业化虚拟机的方式\n\n采用分代收集算法，也即不同的年代采用不同的回收策略\n\n新生代采用复制算法，按照一定的比例默认是8:1:1，分为Eden、From、To三个区域\n\n* Minor GC的过程：开始Eden和From都是空的，新建对象会创建在Eden，一次minor gc时，会把所有存活的对象放到From，清除Eden，下一次gc，Eden和From的存活对象移动到To，清空Eden和From，重复这个过程，当然在过程中会判断对象的年龄阈值，当达到一定的程度会移动到老年代\n\n老年代采用标记整理算法\n\n* Full GC的过程：主要针对老年代的对象进行回收\t\n\n## 垃圾收集器\n\n### Serial\n\n* 单线程，需暂停其他工作线程，复制算法，Client模式下默认新生代收集器\n\n### ParNew\n\n* 多线程版本的Serial，同样需要暂停工作线程，Server模式下新生代收集器\n\n### Parallel Scavenge\n\n* 关注吞吐量，即用户代码执行时间/(用户代码+回收时)，多线程。复制算法\n\n### Serial Old\n\n* 单线程，采用标记整理算法\n\n### Parallel Old\n\n* 多线程，标记整理算法，Parallel Scavenge的年老代版本\n\n### CMS\n\n* 多线程标记清除算法，目标是获取最短垃圾回收停顿时间。优点在于并发收集、低停顿\n  * 初始标记\n  * 并发标记\n  * 重新标记\n  * 并发清除\n\n## G1\n\n相比CMS，改进\n\n1. 基于标记整理算法，不产生内存碎片\n2. 可以精确控制停顿时间\n\n","tags":["技术学习","垃圾回收"]},{"title":"放量下跌","url":"/2020/09/10/放量下跌/","content":"\n　　今日的市场放量下跌，现在持有500股21.95的招商证券下跌0.5，500股25.50的三安光电，没有精确拿到当天的低价，行情全日震荡幅度大，拿到这个筹码不算最好，但也算不错，留有30%的仓位等补仓用。前日受美股影响A股也下跌，今天突破了3260点下挫到3234附近，目前持有的基金收益已经亏损了，科技股受影响严重，也是因为之前重仓科技基金，只能说看错了入场点，但问题不大，中长期还是看涨的，毕竟大环境越差，股市肯定要逆行，年初放出的货币怎么也要流向股市的，只是看上层怎么控场了，既不想急速拉升把场子弄臭，也不想资金跑掉砸盘，这时候就看各个大资金大机构怎么做好这个工作了。平稳的一个点位一个点位往上调整，这也是符合大众对股票市场建立信心的。虽然手上拿点小钱在股票市场实践，但对于股票市场的风险，参与之后是深有体会，指数区间对于个股某个区间的价位十分难以把握，所以对于散户来讲，要拿到好的价位入场很难，在这种震荡市中，小资金用来走短线获利是十分有优势的，但同时一不小心就被套在高点了，所以散户只能说跟着趋势走，把握大趋势。从长远来看，手持蓝筹股是最稳的选择，走价值投资的路子。路漫漫其修远兮，学点理财技能，给出自己的判断观点，对于世界，经济趋势的把握十分有益，知行合一。\n\n","tags":["投资","股票"]},{"title":"牛市?","url":"/2020/08/17/牛市/","content":"\n　　8.17今天的股市红红火火，浙商证券在上周的震荡盘中，亏了6、7个点，后续也没有补仓，虽然看多，600股成本16.44，上周收盘15.50，一块钱的亏损，受可转债转股的影响，担心股价受影响，因此打算换股，看好招商证券20块的价位，但最终没有买入。今天证券板块拉升，招商当了把领头羊，涨停，虽然上周就看出来机构在打压股价，不断地低吸拉成本，可惜了，一波短线没有买入。今天的大盘站到3400以上，拉升过大，后面的量能支撑表示有所怀疑，k线站到了5日线以上，明天之后也会有所回调，今天将手上的浙商16.60清仓了，防止风险，没什么盈利，三安光电25.78的300股，今天到达29.50，比较满意，手上的持仓也没有满上。今天的行情就是撬动金融板块，拉升指数，个股普遍没有大涨，二八行情。后续应该是大盘的板块轮动，今天加仓了手上的科技基金，科技基金之前高拉减仓了，震荡行情中没有什么亏损，提前埋伏科技板，等大盘资金轮动的时候能吃点肉，顺应国家的慢牛行情，小股民跟着赚点小钱，还是要对股市有所敬畏，看好中国的资本市场。","tags":["投资"]},{"title":"茶多酚的功效","url":"/2020/08/15/茶多酚的功效/","content":"\n### 茶多酚\n\n　　英德特产绿茶，号称绿茶中的茶王，期间特别驱车前往本地试茶，相比红茶的烈性，绿茶的茶性比较收敛，就茶感上比较中性，对中枢神经的兴奋作用没有那么大，有促排，消肿的功效 ，个人本身有鼻炎，鼻甲长期处于肿胀的状态，喝绿茶发现鼻甲的肿胀有减缓，脸上的油脂减少，查阅相关资料，发现绿茶中的茶多酚含量相比其他茶种含量较高，因为绿茶的发酵程度低，故而茶多酚含量高。茶多酚对人体有多重功效，特别是一些慢性疾病有一定的疗效。\n\n#### 功效\n\n* 抗氧化\n* 抗炎，鼻炎患者能够有效消肿，对鼻腔的炎症有一定的抑制作用\n* 抗高血脂\n* 延缓衰老\n* 防水肿、抗过敏","tags":["健康"]},{"title":"建仓","url":"/2020/08/07/建仓/","content":"\n　　8.4入场建仓，300股的浙商证券，成本16.65，500股的三安光电，成本26.14。基本是买在跌位，8.6涨了一块钱，在8.7又猛跌猛拉，基本上没有多大的盈利，后续看好，持股不动。\n\n　　8.11，今天尾盘跳水，将这段时间的收益吐回去了，尾盘还加仓了浙商证券，拉低成本到16.44，虽然大盘整体下挫，但是聪明的钱，北上资金净流入60亿，说明在买筹，还是看好后市，持股不动。\n\n","tags":["投资","股票"]},{"title":"深入浅出索引","url":"/2020/07/16/深入浅出索引/","content":"\n### 序\n\n> 索引是数据库中为了提高数据查询速度而使用的一种数据结构，以一种结构化的存储方式来索引相关数据，达到快速查询的目的。通俗的讲类似书的目录，通过目录来查询数据效率会有极大提升。\n\n### 数据结构\n\n 索引常用的数据结构：\n\n* 哈希表\n* 有序数组\n* 搜索树\n\n#### 哈希表\n\n　　适用于等值查询的场景，key通过哈希函数得到一个确定的位置，上面放对应的value。使用链表解决哈希冲突。不适合范围查询，因为需要全表扫描，无法利用索引完成排序，不支持多列联合索引的最左匹配规则，如果有大量重复键值的情况会产生哈希碰撞问题。\n\n#### 有序数组\n\n　　只适用于静态搜索引擎，索引列的数据按照规则排序，查找数据可以直接二分查找，时间复杂度是O(log(N))支持范围查询。缺点是更新数据比较麻烦，需要移动记录。\n\n#### 搜索树\n\n　　大部分数据库引擎采用这种数据结构，读写的性能优点适配磁盘的访问模式。搜索树的特点是左儿子节点的数据小于父节点，父节点小于右儿子节点，每个节点的多个儿子从左到右递增，查询的时间复杂度是O(log(N))。\n\n### InnoDB的索引模型\n\n采用B+树，是一种多路平衡查询树\n\n#### 分类\n\n* 主键索引，也叫聚簇索引，叶子节点存整行数据。\n\n* 非主键索引，叶子节点存放的是主键的值。\n* 覆盖索引，索引上已经覆盖了查询的需求，无需回表。\n\n> 区别：通过非主键索引查找非主键列的话，需要再用主键去主键索引查找相应的数据，这个过程叫回表，也就是多扫描一次索引树。\n\n### 索引维护\n\n　　B+树需要维护索引的有序，因此插入新值时需要维护，如果所在的数据页满了，则要申请一个新的数据页，然后将部分数据迁移过去，这个过程称为页分裂，反过来则称为页合并。\n\n　　采用自增主键插入数据时，由于主键是递增的，因此索引新增都是以追加的方式，不会引起页分裂，如果采用业务逻辑字段做主键，不容易保证有序插入，写数据成本会很高。\n\n### 最左前缀原则\n\n　　索引的搜索匹配按最左前缀匹配，不管是联合索引还是字符串索引的最左M个字符，在构造索引树时，已经按照索引的定义去进行了排序，比如联合索引(a,b)，在存储上也当成一个字节数组，排序也是按字节去比较排序。这也就是为什么会是最左前缀原则生效的原因。\n\n```sql\n联合索引（a,b）\n\n#可以覆盖到a\nselect * from test where a='cc';\n\n#覆盖到a，覆盖不到b，因为中间用了%通配符\nselect * from test where a='cc%' and b='dd';\n\n#覆盖到a和b\nselect * from test where a='cc'  and b='dd';\n```\n\n**索引下推**\n\n>Mysql5.6之后在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。比如联合索引(a,b)，根据a,b条件先筛选出符合条件的数据再进行回表。\n\n### 索引失效\n\n模糊匹配、类型隐转、最左匹配\n\n* %导致没有命中\n* 参数类型跟sql查询的类型不一致，使用了函数\n* 比如说组合索引，由a、b、c组成，查询c没法命中\n\n### 如何排查慢查询\n\n根据explain执行计划，主要关注两个指标，一个是type，是全表还是范围查询，看key是否有命中索引，看rows，返回的行数\n\n工作例子：一个报表查询，数据量100w左右，sql用到了聚合函数，临时表，查询速度到了几秒，通过explain分析，统计部分临时表的数据量很大，实际最后的结果集数据rows仅少量，索引也没有命中，走的是全表扫描，原表的日期用的是char来存，sql语句采用to_date()函数与传入的日期参数比较，导致索引失效，去除函数，并且对聚合查询做提前的条件过滤","tags":["技术学习","索引"]},{"title":"观察者模式","url":"/2020/07/14/观察者模式/","content":"\n### 定义\n\n　　定义对象的一种一对多的依赖关系，当一个对象的状态发生改变，所有依赖它的对象都得到通知并自动更新。\n\n### 场景\n\n　　当一个对象状态发生变化时，依赖的对象需要得到通知时使用。\n\n<!--more-->\n\n![](/assets/blog_img/观察者模式.png)　　\n\n### 代码\n\n#### 被观察对象\n\n```java\npublic class Subject {\n   //目标类保持所有观察者的引用，才能通知到\n   private List<Observer> observers \n      = new ArrayList<Observer>();\n   private int state;\n \n   public int getState() {\n      return state;\n   }\n   //改变状态时，通知所有观察者\n   public void setState(int state) {\n      this.state = state;\n      notifyAllObservers();\n   }\n \n   public void attach(Observer observer){\n      observers.add(observer);      \n   }\n \n   public void notifyAllObservers(){\n      for (Observer observer : observers) {\n         observer.update();\n      }\n   }  \n}\n```\n\n#### 观察者抽象类\n\n```java\npublic abstract class Observer {\n   protected Subject subject;\n   public abstract void update();\n}\n```\n\n#### 实际观察者实现类\n\n```java\npublic class BinaryObserver extends Observer{\n \n   public BinaryObserver(Subject subject){\n      this.subject = subject;\n      this.subject.attach(this);\n   }\n \n   @Override\n   public void update() {\n      System.out.println( \"Binary String: \" \n      + Integer.toBinaryString( subject.getState() ) ); \n   }\n}\n\npublic class OctalObserver extends Observer{\n \n   public OctalObserver(Subject subject){\n      this.subject = subject;\n      this.subject.attach(this);\n   }\n \n   @Override\n   public void update() {\n     System.out.println( \"Octal String: \" \n     + Integer.toOctalString( subject.getState() ) ); \n   }\n}\n```\n\n#### 客户端\n\n```java\npublic class ObserverPatternDemo {\n   public static void main(String[] args) {\n      Subject subject = new Subject();\n\n      new OctalObserver(subject);\n      new BinaryObserver(subject);\n \n      System.out.println(\"First state change: 15\");   \n      subject.setState(15);\n      System.out.println(\"Second state change: 10\");  \n      subject.setState(10);\n   }\n}\n```\n\n","tags":["技术学习"]},{"title":"入场梭哈","url":"/2020/07/07/入场梭哈/","content":"\n　　今天是7.7号，距离昨天开始宣传牛市启动仅一天之隔，作为一条韭菜，进场梭哈300股的招商证券，入手价是29.6，收市价是28.4，额......可以说进场就没了300多块钱，个人预期这波外资短时间不会那么快退场，因为资金吸水的作用还未曾达到，现在的资金来源是外资+机构在烘托，一波氛围烘托出来势必需要有人顶上，没错就是像楼主这样的韭菜，我的看法是现在还在中期，没到下跳的时候，如果我是外资，A股的股价这么低，加上长期的熊市周期，这波疫情下发的货币，总得有地方释放，没错，就是来圈释放的rmb，几天时间靠外资和机构拉到3300多点，剩下的就是要等散户进场，抬到3500以上，然后下跳。我个人预期股价到32块就清掉，不贪心，没错典型的韭菜思维，现在市场的空军是大于多军的，很多人在这波上涨中，吸取了年前的教训不恋战，及早止盈，离场，但我的看法还是那句话，增量的资金在对冲这些放量，大盘是下不来的，所以会造成及早下车的人在揪心少了几个点，其实都是没意义的，市场的变化太快没人能判断准，只要还在赌盘上，就没有赢家，我一直是这个思维，有人的地方就会一直有市场，有市场就会一直有买卖，资产总是放在那里，就看是否有交易的价值了，这些逃跑的资金我猜测它们的心理变化是会再度杀回来，而且会无比地猛烈，好了就看明天打脸了。\n\n　　2020.7.8\n\n　　今天最高跳到31块，股票公告说要停牌10天，10天后行情不知道啥样子，惊心动魄地在29.8抛了，净赚42块，第一次买股票，发现太刺激了，一上一下，几百块对于我这些小韭菜真觉得不是一般人能玩得起的，从7.1到现在，基金果断买了军工、消费、科技，刚好持有7天，而且是天天2-3个点的盈利，军工提前看好买了2000，才一周就17%的收益就很可怕的收益，从年前的经验来看，真的会来波跳水将这些收益给吸掉，现在的拉升是90°上升，这完全就是靠大资金拉上去的，到底场外资金的看客有多少不好说，看空的人都在等跳水进场收尸，如果市场完全无视呢，硬生生拉到3500点以上，那么也更加不敢进场了，营造出你不信我偏上的一种资本态度，还是要敬畏市场，适度止盈，还是那句话一天还在赌盘上，谁赢谁输还不好说。\n\n　　2020.7.10\n\n\n\n　　从6.30到今天，短短10天，2w的基金持仓，收益净赚2000，今天兑现收益，这收益率在平时可能要几个月才能达到，生生体会到资本的力量，只有兑现才真的是袋袋平安，今天的行情小幅度下跌，北向资金负流入了，昨晚美股大调整，说明这些天外资是在避险才把资金疯狂买入A股市场，现在已经是净流出了，个人看法是A股这波牛市行情快到点了，今天就兑现，提前避险，毕竟这些天的收益已经很满足了，留下一只长期看好的科技基金，持半仓，即使跌也跌不了多少，毕竟长期看好，后面跌下来再慢慢定投，相信时间的力量吧。\n\n","tags":["投资"]},{"title":"单点登录","url":"/2020/07/06/单点登录/","content":"\n**定义**\n\n> 单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。\n\n**概览**　　\n\n　　客户端会访问三个系统中的一个，当初次登录Node2时，首先去sso验证登录，之后访问Node1、Node3都无须再次登录。\n\n![](/assets/blog_img/sso.png)\n\n**SSO登录流程**\n\n* 用户访问Node1，判断未登录。\n* 跳转到CAS server，弹出登录页。\n* 填写用户密码登录成功，session写入CAS server，将server ticket返回给客户端，客户端拿到ST去访问Node1。\n* Node1拿ST去CAS server验证有效性。\n* 通过后Node1写入session并设置Cookie。\n\n","tags":["技术学习"]},{"title":"策略模式","url":"/2020/07/06/策略模式/","content":"\n**定义**\n\n　　类的行为在运行时可以更改，根据策略选择不同的执行算法。\n\n<!--more-->\n\n**什么时候使用**\n\n　　程序需要根据某个条件选择不同的执行方式时，一般会使用if/else分支逻辑，但不利于维护，如果只是执行方式不同，可以使用策略模式。\n\n**特点**\n\n　　避免多重判断，扩展性好。\n\n![](/assets/blog_img/策略模式.png)\n\n**代码**\n\n**策略接口**\n\n```java\npublic interface Strategy {\n   public int exec(int n);\n}\n```\n\n**策略执行子类**\n\n```java\npublic class Add implements Strategy {\n   public int exec(int n){\n     return n+1;\n   }\n}\n\npublic class Sub implements Strategy {\n   public int exec(int n){\n     return n-1;\n   }\n}\n\npublic class Mul implements Strategy {\n   public int exec(int n){\n     return n/1;\n   }\n}\n```\n\n**执行对象**\n\n```java\npublic class Context {\n   private Strategy strategy;\n \n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n \n   public int executeStrategy(int n){\n      return strategy.exec(n);\n   }\n}\n```\n\n**客户端**\n\n```java\npublic class Client {\n   public static void main(String[] args) {\n      Context context = new Context(new Add());    \n      context.exec(10);\n \n      context = new Context(new Sub());      \n      context.exec(10);\n     \n      context = new Context(new Mul());    \n      context.exec(10);\n\n   }\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"redis分布式锁实现秒杀业务","url":"/2020/07/02/redis分布式锁实现秒杀业务/","content":"\n　　曾经做过一个类似秒杀系统的模块，系统采用分布式架构，场景是这样子的，用户提了故障单后，有跟踪故障单的需求，衍生了催单，用户会通过多个客户端去提交催单，用户催单有专人去跟踪，有一定的时效性，需要及时处理反馈。\n\n<!--more-->\n\n业务规则\n\n* 同一个工单号一个用户15分钟内只能提一次催单\n* 同一个工单号不同用户15分钟内只产生一条催单，新增的用户则追加子记录\n\n**问题**\n\n1. 需要考虑并发操作\n2. 保证分布式环境下业务的正确处理\n3. 考虑大流量请求下服务处理压力\n\n　　虽然系统是运营商的内部系统，tob的用户量并不会很大，但站在技术角度，需要考虑如果toc要怎么满足的问题。首先处理并发问题，因为多个用户对于同一个工单的业务操作是竞争的，因此需要对同一个工单号上锁，其次要满足高可用，因此在多服务运行环境下，需要引入分布式锁，查了下分布式锁的解决方案可以使用redis或者数据库锁（通过数据库插入记录的唯一性保证），这里使用redis分布式锁来解决，且针对用户的重复查询，使用redis缓存来降低DB的压力，这样15分钟内用户的多次查询都能命中缓存，以此解决问题3。\n\n**分布式锁的方案及原理**\n\n* 数据库加锁\n\n  数据库锁主要是利用行记录的唯一性来保护资源，插入失败即继续重试，直至获取到锁。需要自己考虑锁超时，事务等。\n\n* Redis锁\n\n  利用sexNx方法的原子特性实现，多个进程竞争set值，只有一个进程set成功则为获取锁成功，需要设置锁的过期时间防止宕机，redis2.8以前需要使用lua脚本来保证setNx与过期时间设置保证原子操作，2.8以后能支持nx和ex是同一操作。可以使用redission客户端，封装了锁的实现。\n\n* zookeeper锁\n\n  使用Curator框架，其封装了zookeeper的API，提供分布式锁的实现。原理是zookeeper有一个临时有序节点的概念，在某个目录加锁会生成一个节点，后来的客户端会有序生成排列，然后先到的客户端会检测自己是不是第一个节点，是的话就加锁成功，否则寻找当前节点的上一个节点，并且添加监听器。当上一个节点操作完毕释放锁会删除自己的节点，此时监听到删除的下一个节点会尝试获取。这里不用保证超时，因为zookeeper能够检测客户端的健康状态，当失活后能够删除当前节点，这也就是zookeeper锁的原理\n\n![流程图](/assets/blog_img/用户并发催单流程.png)\n\n**伪代码**\n\n```java\nvoid submitCallOrder(String orderNum, String userName){\n  String cacheUserOrderNum;\n  //缓存取是否催单，key以用户+工单号\n  cacheUserOrderNum=template.opsForValue().get(userName+\":\"+orderNum);\n  if(Strings.isNotBlank(cacheUserOrderNum)){\n\t\t//用户已催单\n  }\n  \n  //加锁，获取不到一直阻塞\n  while(!redisLockHelper.lock(orderNum,String.valueOf(time))){};\n\n  //查询是否有15分钟内的催单\n  Order dbOrder=orderMapper.existLatestCallOrder(orderNum);\n  if(dbOrder==null){\n    //没有则新增催单\n    orderMapper.insert(order);\n    //新增催单用户子记录\n    subOrderMapper.insert(subOrder);\n    //缓存数据\n    template.opsForValue().set(userName+\":\"+orderNum,\"1\", TimeUnit.MINUTES.toMinutes(15));\n  }else{\n    //用户15分钟内是否催过单\n    if(subOrderMapper.existLatestSubCallOrder(orderNum,userName)){\n      //缓存数据\n      template.opsForValue().set(userName+\":\"+orderNum,\"1\", TimeUnit.MINUTES.toMinutes(15));\n    }else{\n      //新增催单用户子记录\n      subOrderMapper.insert(subOrder);\n   \t\t//更新催单主记录最近催单时间\n      orderMapper.updateByPrimaryKeySelective(order);\n      //缓存数据\n      template.opsForValue().set(userName+\":\"+orderNum,\"1\", TimeUnit.MINUTES.toMinutes(15));\n    }\n  }\n  \n  //释放锁\n  redisLockHelper.unlock(orderNum,String.valueOf(time));\n}\n```\n\n**Redis分布式锁工具类**\n\n```java\npublic class RedisLockHelper {\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    /**\n     * 加锁\n     * @param targetId   targetId - 唯一标志\n     * @param timeStamp  当前时间+超时时间 也就是时间戳\n     * @return\n     */\n    public boolean lock(String targetId,String timeStamp){\n        if(stringRedisTemplate.opsForValue().setIfAbsent(targetId,timeStamp)){\n            // 对应setnx命令，可以成功设置,也就是key不存在\n            return true;\n        }\n\n        // 判断锁超时 - 防止原来的操作异常，没有运行解锁操作  防止死锁\n        String currentLock = stringRedisTemplate.opsForValue().get(targetId);\n        // 如果锁过期 currentLock不为空且小于当前时间\n        if(!Strings.isNullOrEmpty(currentLock) && Long.parseLong(currentLock) < System.currentTimeMillis()){\n            // 获取上一个锁的时间value 对应getset，如果lock存在\n            String preLock =stringRedisTemplate.opsForValue().getAndSet(targetId,timeStamp);\n\n            // 假设两个线程同时进来这里，因为key被占用了，而且锁过期了。获取的值currentLock=A(get取的旧的值肯定是一样的),两个线程的timeStamp都是B,key都是K.锁时间已经过期了。\n            // 而这里面的getAndSet一次只会一个执行，也就是一个执行之后，上一个的timeStamp已经变成了B。只有一个线程获取的上一个值会是A，另一个线程拿到的值是B。\n            if(!Strings.isNullOrEmpty(preLock) && preLock.equals(currentLock) ){\n                // preLock不为空且preLock等于currentLock，也就是校验是不是上个对应的商品时间戳，也是防止并发\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * 解锁\n     * @param target\n     * @param timeStamp\n     */\n    public void unlock(String target,String timeStamp){\n        try {\n            String currentValue = stringRedisTemplate.opsForValue().get(target);\n            if(!Strings.isNullOrEmpty(currentValue) && currentValue.equals(timeStamp) ){\n                // 删除锁状态\n                stringRedisTemplate.opsForValue().getOperations().delete(target);\n            }\n        } catch (Exception e) {\n            log.error(\"警报！警报！警报！解锁异常{}\",e);\n        }\n    }\n}\n```\n\n[github源码地址](https://github.com/mokitkira/order/tree/master)\n\n","tags":["技术学习","redis","缓存"]},{"title":"模板模式","url":"/2020/07/01/模板模式/","content":"\n**定义**\n\n> 在一个抽象类中定义了方法的模板，子类可以按照需要重写，调用以抽象类中定义的方式执行。\n\n**什么时候使用**\n\n　　有一些通用的方法时，步骤基本一样，可以将通用的步骤抽象出来，具体的实现方法留给子类去实现。\n\n<!--more-->\n\n**特点**\n\n　　封装不变部分，扩展可变部分，提取公共代码。缺点是每一个不同的实现都需要一个子类实现，子类数量庞大。\n\n![](/assets/blog_img/模板模式.png)\n\n**代码**\n\n**抽象模板类**\n\n```java\npublic abstract AbstractHouse{\n  final void decorate(){\n    //抽象出模板步骤，具体方法留给子类实现\n    decorateDoor();\n    decorateWall();\n    decorateWindow();\n  }\n  \n  abstract　void decorateDoor();\n  \n  abstract　void decorateWall();\n  \n  abstract　void decorateWindow();\n  \n}\n```\n\n**扩展实现类**\n\n```java\npublic class SubHouse{\n    \n  void decorateDoor(){\n    System.out.println(\"装饰地板\");\n  }\n  \n  void decorateWall(){\n    System.out.println(\"装饰墙面\");\n  }\n  \n  void decorateWindow(){\n    System.out.println(\"装饰窗户\");\n  }\n  \n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n  public static void main(String args[]){\n    AbstractHouse house = new SubHouse();\n    house.decorate();\n  }\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"事务","url":"/2020/06/30/事务/","content":"\n**事务的定义**\n\n>事务是数据库管理系统执行过程的一个逻辑单位，通俗地讲，一件事要么一次做完，要么不做。\n\n**事务的特性（ACID）**\n\n* **原子性（Atomicity）**：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n* **一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。*一致状态*的含义是数据库中的数据应满足完整性约束。\n* **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n* **持久性（Durability）**：已被提交的事务对数据库的修改应该永久保存在数据库中。\n\n**例子**\n\n　　比如去银行存款这个事务，分为几个操作，首先查询账户余额，修改余额，然后提交，这就是一个事务。\n\n<!--more-->\n\n**事务隔离级别**\n\n> 事务与事务会共同影响同一条数据，比如两个人同时操作一个账户就会引发各种问题，隔离级别决定了两个事务同时操作的作用范围。\n\n* 读未提交\n\n  |                事务A                |           事务B           |\n  | :---------------------------------: | :-----------------------: |\n  |                Begin                |           Begin           |\n  |                                     | 更新id=3的数据status=true |\n  | 查询id=3的数据，读到数据status=true |                           |\n  |                                     |          Commit           |\n  |               Commit                |                           |\n\n* 读已提交\n\n  |                事务A                 |           事务B           |\n  | :----------------------------------: | :-----------------------: |\n  |                Begin                 |           Begin           |\n  |                                      | 更新id=3的数据status=true |\n  | 查询id=3的数据，读到数据status=false |                           |\n  |                                      |          Commit           |\n  | 查询id=3的数据，读到数据status=true  |                           |\n  |                Commit                |                           |\n\n* 可重复读\n\n  | 事务A                                | 事务B                     |\n  | ------------------------------------ | ------------------------- |\n  | Begin                                | Begin                     |\n  |                                      | 更新id=3的数据status=true |\n  | 查询id=3的数据，读到数据status=false |                           |\n  |                                      | Commit                    |\n  | 查询id=3的数据，读到数据status=false |                           |\n  | Commit                               |                           |\n\n* 串行\n\n  | 事务A                               | 事务B                     |\n  | ----------------------------------- | ------------------------- |\n  | Begin                               | Begin                     |\n  |                                     | 更新id=3的数据status=true |\n  | 查询id=3的数据，阻塞                |                           |\n  |                                     | Commit                    |\n  | 查询id=3的数据，读到数据status=true |                           |\n  | Commit                              |                           |\n\n**事务的传播行为**\n\n> 从代码的层面上讲，就是方法的嵌套调用过程中，方法A对其子方法B的调用过程中，对其事务的影响范围。\n\n* PROPAGATION_REQUIRED：支持当前事务，假设当前没有事务。就新建一个事务\n\n  方法A调用子方法B，A自动起一个事务，如果B没有起事务，自动加入到A事务中。\n\n* PROPAGATION_SUPPORTS：支持当前事务，假设当前没有事务，就以非事务方式运行\n\n  方法A调用子方法B，B会看当前有没有事务，有则加入，无则以非事务运行\n\n* PROPAGATION_MANDATORY：支持当前事务，假设当前没有事务，就抛出异常\n\n  方法A调用子方法B，B会看当前有没有事务，有则加入，无则抛异常\n\n* PROPAGATION_REQUIRES_NEW：新建事务，假设当前存在事务。把当前事务挂起\n\n  方法A调用子方法B，B会起一个新事务，B的事务提交后，A的事务才会继续运行，B的事务失败回滚，A事务还是有可能提交\n\n* PROPAGATION_NOT_SUPPORTED：以非事务方式运行操作。假设当前存在事务，就把当前事务挂起\n\n  方法A调用子方法B，A事务挂起，B以非事务运行\n\n* PROPAGATION_NEVER：以非事务方式运行，假设当前存在事务，则抛出异常\n\n  方法A调用子方法B，B发现在A的事务中，就抛出异常\n\n* PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。\n\n  ","tags":["技术学习","数据库"]},{"title":"基金布局","url":"/2020/06/30/基金布局/","content":"\n　　上半年疫情看好的医疗板块，没有坚定持有，当时的想法是持有至六月份，判定依据是国内是最早稳定疫情的，外部环境的综合生产能力或者控制能力相对中国这种集大力办大事的处理能力肯定是完全不在一个等级上的，因此中国这个外贸型国家在一段时间内必然是医疗设备输出国，有需必有供，在此认为下半年医疗还是可以持有的。另外就是布局消费、航空、军工、科技。\n\n<!--more-->在低净值开始针对消费，军工建仓，当前中国的地缘环境，在全球经济衰退的这个阶段，必然是背锅对象，近期的西部中印边境对峙，或者朝韩关系紧张，抑或东部台湾与日本，都是美国转移经济下行制造事端的一种潜在手段，中国势必会通过秀肌肉，加强军工产业，实战化演练来起到震慑周边国家的效果，因此军工相关的产业链会利好。至于消费或者航空，在经济下行的阶段，想将GDP20%外贸转内需，说实话，个人感受，在房价及物价飞涨的情况下，每个人或多或少都能感受到经济冲击的影响，必然会由消费走向储蓄，尽管政府的基调是通过内需来消耗掉，拉动消费，拉动经济增长，这是一个点，相对会有所增长，这是我判断的依据，但前面说了物价与房价决定了大多数人的消费心理，那么少部分消费基数在我看来是起不了大作用的，当前3%的通胀及银行如此低的利率。居民的心理必然会将钱拿出来投资，问题是钱会流向哪里？个人并不看好房产，一来是国家的定调，二来房产的泡沫没有对应的生产力与购买力，势必只是有价无市，只能是国家作为稳定市场的手段。所以我认为钱会流向股市，国内A股尚且处于低估值阶段，有很大的上升空间，这波上涨需要一个推力，我预估将会来自于外资。一个是稳定健康的市场环境，尽管政治上不待见，但对于资本家来说，资本无国界，国家也在营造一个健康的资本环境，为的也就是吸引外资，吸引国内的资本，推动股市上行，这样才能消解掉这次黑天鹅带来的危机，货币的市场流动性，社会分工的再循环，这才是重中之重。我的决策是消费航空军工开始建仓，逐步重仓医疗与科技，是成是败就看半年后回首今天写下的内容了。","tags":["投资","基金"]},{"title":"浅拷贝与深拷贝","url":"/2020/06/28/浅拷贝与深拷贝/","content":"\n**前言**\n\n　　一般在Java中我们创建一个对象是使用new关键字来创建的，new关键字会调用类的构造方法来创建对象，那么有一些场景我们想以现成的对象为模板来复制对象，回避构造函数的过程，毕竟构造函数中或多或少会有初始化的过程，性能难免较低，这时候就可以考虑使用拷贝，copy一个对象。\n\n<!--more-->\n\n**实例**\n\n以下这个类创建对象如果使用new关键字，调用构造函数会消耗较多时间。\n\n```java\npublic class Person{\n  String name;\n  int age;\n  public Person(){\n    try{\n      //模拟构造函数初始化需要较多的性能\n      Thread.sleep(1000);\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n**clone方法代替Person**\n\n我们如果想直接复制一个对象，使用现有对象，避免多余的代码，可以使用clone方法，这个是Object的方法，默认实现会返回现有对象的拷贝，但仅仅是浅拷贝。\n\n> 浅拷贝：快速复制一个对象，底层调用的是本地方法，对于基本数据类型会直接复制到新对象，而对象类型，仅仅是将引用指向原有对象的地址空间，即是复制后的对象与复制前的对象，对象中的引用对象都是同一个对象。\n\n```java\npublic class Person implements Cloneable{\n  String name;\n  int age;\n  Vector v;\n  public Person(String name,int age){\n    try{\n      //模拟构造函数初始化需要较多的性能\n      Thread.sleep(1000);\n      this.name=name;\n      this.age=age;\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n  @Override\n  protected Object clone() throws CloneNotSupportedException {\n             return super.clone();\n  }\n  public static void main(String args[]){\n     Person p = new Person(\"Ben\",20);\n     p.v=new Vector();\n     Person c = (Person) p.clone();\n     log.info(p.name+\":\"+p.age);\n     log.info(c.name+\":\"+c.age);\n     log.info(\"{}\",p==c);\n     log.info(\"{}\",p.v==c.v);\n  }\n}\n```\n\n>深拷贝：在浅拷贝的基础上，如果我们想把对象的对象类型也按照新的对象的创建，即分配一块新的内存空间，则需要在clone方法中重写相应的实现。\n\n```java\n@Data\n@Slf4j\npublic class CloneDemo {\n     static class Person implements Cloneable{\n        String name;\n        int age;\n        Vector v;\n        public Person(String name,int age){\n            try{\n                //模拟构造函数初始化需要较多的性能\n                Thread.sleep(1000);\n                this.name=name;\n                this.age=age;\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n\n         @Override\n         protected Object clone() throws CloneNotSupportedException {\n             Person t = (Person)super.clone();\n             Vector vv = new Vector();\n             Collections.copy(vv,t.v);\n             t.v=vv;\n             return t;\n         }\n     }\n    public static void main(String args[]) throws CloneNotSupportedException {\n        Person p = new Person(\"Ben\",20);\n        p.v=new Vector();\n        Person c = (Person) p.clone();\n        log.info(p.name+\":\"+p.age);\n        log.info(c.name+\":\"+c.age);\n        log.info(\"{}\",p==c);\n        log.info(\"{}\",p.v==c.v);\n    }\n}\n```\n\n","tags":["技术学习","Java基础"]},{"title":"原型模式","url":"/2020/06/28/原型模式/","content":"\n**定义**\n\n> 根据原型实例创建对象的种类，并通过拷贝原型来创建新的对象。\n\n**实现方式**\n\n* 实现Cloneable接口。在java中实现了此接口的类才可以被拷贝。\n* 重写Object的clone方法，Object的clone方法作用域是protected类型，需要重写修改作用域为public。\n\n<!--more-->\n\n**特点**\n\n　　比new对象性能好，clone方法调用本地方法复制对象。不会调用类的构造方法。clone方法只会浅拷贝，即是拷贝对象的基本数据类型，若要实现深拷贝，重写方法中需要针对数组、容器对象、引用对象做另外的拷贝。\n\n**代码**\n\n```java\nclass Prototype implements Cloneable {\n  private ArrayList list = new ArrayList();\n\n\tpublic Prototype clone(){\n\t\tPrototype prototype = null;\n\t\ttry{\n\t\t\tprototype = (Prototype)super.clone();\n      prototype.list = (ArrayList) this.list.clone();\n\t\t}catch(CloneNotSupportedException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn prototype; \n\t}\n}\n \nclass ConcretePrototype extends Prototype{\n\tpublic void show(){\n\t\tSystem.out.println(\"原型模式实现类\");\n\t}\n}\n \npublic class Client {\n\tpublic static void main(String[] args){\n\t\tConcretePrototype cp = new ConcretePrototype();\n\t\tfor(int i=0; i< 10; i++){\n\t\t\tConcretePrototype clonecp = (ConcretePrototype)cp.clone();\n\t\t\tclonecp.show();\n\t\t}\n\t}\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"JSON Web Token","url":"/2020/06/26/JSON-Web-Token/","content":"\n**定义**\n\n> 是一种跨域认证的令牌技术。\n\n**解决场景**\n\n1. 用户向服务器发送用户名和密码。\n\n2. 服务器验证通过后，则在session中保存用户的相关信息，如用户角色，权限等。\n\n3. 服务器返回一个sessionId给客户端 ，写入浏览器的cookie中。\n\n   <!--more-->\n\n4. 用户的每次请求都带上seesionId。\n\n5. 服务端找到sessionId，知道用户的身份。\n\n> 缺点：单机没问题，集群或者跨域，则需要session共享。一种方案是将session持久化，每个服务受到请求都请求持久层。\n\n　　JWT的方案：服务端不在保存session，session保存在客户端，每次请求发送给服务端。\n\n**原理**\n\n　　服务端认证后，生成一个JSON对象给客户端，以后客户端就用这个对象去跟服务端交互，防止数据被篡改，需要对其进行签名，可以理解为配一对无法修改的钥匙，用户可以用其来开门。\n\n**数据结构**\n\n头部（header）\n\n```json\n{ \n    “typ”: “JWT”, \n    “alg”: “HS256” \n} \n```\n\n有效载荷（PayLoad）\n\n```\n{ \n    “iss”: “Online JWT Builder”, \n    “iat”: 1416797419, \n    “exp”: 1448333419, \n    ……. \n    “userid”:10001 \n} \n```\n\n签名\n\n> 将Header和Playload拼接生成一个字符串,str=“eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyaWQiOjB9”，使用HS256算法和我们提供的密钥（secret,服务器自己提供的一个字符串）对str进行加密生成最终的JWT，即我们需要的令牌（token），形如：str.”签名字符串”。\n\n**交互过程**\n\n1、客户端通过用户名和密码登录\n\n2、服务端进行鉴权，通过则返回token给客户端\n\n3、客户端收到token后每次访问服务端都带上该token，相当于令牌表示有权访问\n\n4、服务端一般会在网关验证token的合法性，若token合法，则允许请求，若token不合法或者过期，返回请求失败\n\n**JWT的时序图**\n\n![](/assets/blog_img/基于token身份认证方案.png)\n\n**验证token有效性**\n\n> HS256加密算法：使用对称算法加密，共享同一个密钥，验证的时候，取头部和载荷base64后的字符串再使用该算法加密，将生成与传过来的签名比对，一致则有效。\n>\n>  RS256加密算法：使用非对称算法加密，提供方使用私钥加密后，生成签名，接收方使用公钥验证签名\n\n**特点**\n\n1. JWT默认不加密，可以生产token后再用密钥加密一次。\n2. 不加密时不能将敏感数据写入body。\n3. 可以降低服务端的查库压力，因为每次仅校验token。\n4. 缺点是token生成后续签难，且无法废弃。\n5. 尽可能使用https协议传输。\n\n**实践**\n\n> 项目架构是微服务架构，采用JWT鉴权与数据交互，采用RSA256非对称加密算法，统一通过gateway进行token的合法性校验。\n\n","tags":["技术学习","JWT"]},{"title":"调理脾胃","url":"/2020/06/26/调理脾胃/","content":"\n　　近来生活不规律，饮食好生冷，多熬夜，作息不规律，感觉脾胃瘀滞，气机不畅感明显。查阅中医相关资料，是为脾胃虚弱之症。\n\n### 判定\n\n1. 舌头边缘有齿痕，湿气重，脾胃虚\n2. 食欲下降，转化率差\n3. 早起不适，起床就胸闷气短，头晕。\n4. 湿气重\n\n### 如何养脾胃\n\n* 忌生冷\n* 忌多\n* 忌忧思过度\n* 适量服用归脾丸或补中益气丸提升脾胃的运化\n* 慢跑运动提升血液循环，提升脾胃的运化能力，且能去除体内的湿气。\n\n> 健康是革命的资本，关注健康，关注自我。\n\n","tags":["健康"]},{"title":"FTP模式设置引发的问题","url":"/2020/05/21/FTP模式设置引发的问题/","content":"\n### 前言\n\n　　最近写了一个程序使用FTP去服务器批量下载文件，按道理应该是比较简单的。但上了生产环境就发生了异常，程序下载的过程中莫名其妙进入假死状态，日志也没有继续打，起初以为是递归加载文件的时候找不到出口，后来经过排查原因是FTP的工作模式问题引起的。\n\n### FTP的工作模式\n\nFTP工作端口默认有两个，通常21是命令端口，20是数据端口，当混入主被动模式，数据端口就不一定是20了。\n\n* 主动模式（PORT）\n* 被动模式（PASV）\n\n#### 主动模式\n\n　　FTP默认是启动主动模式，client与server的21端口建立连接后，client随机开放一个1024以上的端口，发送命令给server，告诉server我client将采用主动模式并开放端口，server主动连接并传输。\n\n#### 被动模式\n\n　　不同点在于在建立了连接后，client发送pasv命令给server，server随机开放一个端口给client，简单说就是让server告诉client应该连接哪个端口来进行数据传输，server是被动等待client连接的。\n\n### 分析\n\n　　程序发生假死的原因是因为默认采用主动模式，当服务器连接客户端的传输端口时，有可能被客户端防火墙挡住，采用被动模式让服务端打开随机端口，被动等待客户端进行连接。","tags":["技术学习"]},{"title":"Linux文件删除原理","url":"/2020/05/14/Linux文件删除原理/","content":"\n　　Linux磁盘上的文件有两个link计数器，分别是i_count和i_link，表示进程的引用计数和硬连接的数量。只有当i_count=0并且i_link=0才会删除文件。当我们使用rm命令时，只是使i_link减少，如果此时文件依然被进程引用，文件还未被真正的删除。\n\n**实践场景**\n\n　　实现的一个功能点是通过FTP将文件从其他机子同步到本机，需要删除本机当日的数据，覆写新的数据，并且这些数据会被一个程序定时读取使用。这里的问题是如果此时程序正在读取数据，而同步程序也在跑，会不会影响业务。首先这里程序不涉及写操作，只读，那么当同步程序删除文件时，应用程序load到内存中，完成业务操作都是在内存中，当然如果发生程序异常，那么重跑也会以最新的文件为基础。\n\n","tags":["技术学习","Linux"]},{"title":"布隆过滤器","url":"/2020/05/12/布隆过滤器/","content":"\n# 布隆过滤器\n\n> 在防止缓存穿透场景中，接触到布隆过滤器这个东西，总结下个人对这玩意的理解\n\n# 组成\n\n简单来说，这个东西就是由一个bit数组和几个哈希函数组成，数组上只存放0或1，好处就是这个数组可以搞得非常大，毕竟bit数组，100w的数据，撑死 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\n\n# 用法\n\n**加入元素**\n\n　　加入元素先拿这个元素通过几个hash函数去算一下值，然后将数组上的这几个位置的值设为1\n\n**搜索元素**\n\n　　同样也是用这个元素通过几个hash函数去算一下值，然后判断数组上的这几个位置的值是否1，如果都为1，则说明元素存在，否则元素不在。存在的问题是有可能同一个元素算出同一个位置的值，存在误判的概率，但是如果存在不为1，则肯定是不存在这个元素。\n\n# 解决场景\n\n* 判断一个数字是否存在大量的数字集中\n* 防止缓存穿透\n* 邮件的垃圾邮件过滤、黑名单\n\n","tags":["技术学习"]},{"title":"软件工程实践","url":"/2020/05/09/软件工程实践/","content":"\n>　　在软件工程工作实践中，很多时候由于项目工期紧，一个需求提出后，由于急于落地结果，前期的需求调研的时间可能只有一两次的需求会议，作为开发人员，个人体会是在会议中陷入考虑编码和实现的思维中，往往这会造成开发人员对于需求的理解不准确，有时由于业务点或者业务规则过多，会给初次接触需求的开发人员过大的压力，从不理解需求开始，就开始实践编码，往往会造成不可避免的返工，如果团队有专业的需求分析人员，从需求分析人员到开发人员的沟通传递中，不可避免会遗漏信息，若果没有落地的需求文档，更加如此。因此在需求会议中应该以业务人员的角度，抛开开发人员的思维方式，无需考虑编码细节，因为这往往会影响我们的理解和会议的效果，站在对方的角度去思考，但需要考虑的是软件设计合理性，毕竟业务人员不懂技术，也不一定懂软件设计，必须引导用户，保证软件交互的合理性。\n>\n>　　作为开发人员需要清楚需求才可动手，只有当手上输出了该有的设计文档开始编码才能做到胸有成竹，以文档来驱动开发的好处在于，当业务快速变化的时候，能够适时查阅新增的业务点对现有的业务流程和程序流程的影响会有多大，改动一个点会造成多大的影响。\n>\n>　　从个人的实践来看，对于一个从零开始的需求，至少包含以下几个文档\n>\n>　　1、业务需求文档，包含业务提出的所有需求点和业务规则。\n>\n>　　2、程序流程图，需要开发根据业务需求说明书转化成程序流程图，程序流程可以作为与业务确认的稿件，保证设计方案不会与业务需求有较大的差距，最终的稿件应该是编码的可依据基础。\n>\n>　　3、ER图，数据库表设计，这两个工具应该能确保扩展性，否则后续的加表返工设计数据表或者加表成本都会引发一系列的编码成本。\n>\n>　　如果团队是需要应对快速变化的业务，那么引入敏捷开发的工程模式是比较适合的，当有了以上几个文档后，以最简单的方式构建代码架子，不考虑过多的设计，设计一个核心的架构，慢慢改进，不需要就干掉，交付最小成果，快速反馈业务人员，与业务人员探讨改进。","tags":["技术学习","工作感悟"]},{"title":"投资思考","url":"/2020/02/21/投资思考/","content":"\n>　　高度信息化的社会，身处巨大的信息洪流中，每个社会个体接触信息源的渠道丰富多样，有效甄别信息的有效性并能形成投资的决策根据。市场的变化来源于大众对于当下事态的反应，抓去这种心理变化，去洞察分析，进行投机获取相应的收益。\n>\n>　　市场是自由交易的。\n>\n>　　劳动产生报酬，个人对雇主负责，雇主角度来讲，只有当你的有效成果直接或间接促成公司收益，才是有效的，才能提高你的议价权。你的职位价格由市场供需关系确定，其上限最终会受限与市场整体的价位，除非你能够通过差异性综合提高公司收益，不仅仅你的职位能力。\n>\n>　　投资性收入来源于个人对市场的把握，手段及渠道是多样化的，决策的正确根据对市场未来一段时间的预测，市场是敏感的，是大众心里变化的反映，如何从其中抽取对未来有效的信息源，并根据时势预估未来一段时间的市场变化，作出相应的投资决策，其正确性只能在你的收益中得到反映。","tags":["理哲"]},{"title":"Web实时消息推送","url":"/2019/12/20/Web实时消息推送/","content":"\n### 序\n\n> 一个Web项目中，构建过一个消息推送服务，项目使用SpringCloud微服务架构，系统多数的业务场景是发送邮件通知系统用户，为了提高系统的用户粘度，希望通过系统内的实时通知来取代邮件服务。\n\n### WebSocket\n\n#### 背景\n\n　　ws出现之前，网站实时消息技术一般采用http轮询，这种方式缺点明显，由于http协议消息包含的头部信息较长其中的有效会消耗大量的带宽资源。ws通过兼容80和443端口来实现客户端与服务端的全双工通信。\n\n#### 特点\n\n* 减少控制开销\n* 更强的实时性\n* 保持连接状态，是有状态协议\n* 可以传输二进制数据\n\n#### 协议细节\n\n![](/assets/blog_img/1513538-20200602171824968-160895943.jpg)\n\n1. 客户端通过http协议发起连接请求，Upgrade字段是websocket，表明需要升级为ws进行通讯。\n2. 服务端收到请求后，返回101状态码表示理解，并返回Upgrade消息头表明采用ws来处理请求。\n\n**客户端请求头**\n\n```html\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n**服务端请求头**\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n### SpringBoot搭建WebSocket服务\n\n> 最简单的消息推送模型，前端+后端服务对应客户端与服务端\n\n#### 依赖\n\n```maven\n<dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n#### 配置类\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.server.standard.ServerEndpointExporter;\n\n@Configuration\npublic class WebSocketConfig {\n    /**\n     * ServerEndpointExporter 作用\n     *\n     * 这个Bean会自动注册使用@ServerEndpoint注解声明的websocket endpoint\n     *\n     * @return\n     */\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n}\n```\n\n#### 核心处理类\n\n```java\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n@ServerEndpoint(\"/webSocket/{sid}\")\n@Component\npublic class WebSocketServer {\n    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static AtomicInteger onlineNum = new AtomicInteger();\n\n    //concurrent包的线程安全Set，用来存放每个客户端对应的WebSocketServer对象。\n    private static ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    //发送消息\n    public void sendMessage(Session session, String message) throws IOException {\n        if(session != null){\n            synchronized (session) {\n//                System.out.println(\"发送数据：\" + message);\n                session.getBasicRemote().sendText(message);\n            }\n        }\n    }\n    //给指定用户发送信息\n    public void sendInfo(String userName, String message){\n        Session session = sessionPools.get(userName);\n        try {\n            sendMessage(session, message);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    //建立连接成功调用\n    @OnOpen\n    public void onOpen(Session session, @PathParam(value = \"sid\") String userName){\n        sessionPools.put(userName, session);\n        addOnlineCount();\n        System.out.println(userName + \"加入webSocket！当前人数为\" + onlineNum);\n        try {\n            sendMessage(session, \"欢迎\" + userName + \"加入连接！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    //关闭连接时调用\n    @OnClose\n    public void onClose(@PathParam(value = \"sid\") String userName){\n        sessionPools.remove(userName);\n        subOnlineCount();\n        System.out.println(userName + \"断开webSocket连接！当前人数为\" + onlineNum);\n    }\n\n    //收到客户端信息\n    @OnMessage\n    public void onMessage(String message) throws IOException{\n        message = \"客户端：\" + message + \",已收到\";\n        System.out.println(message);\n        for (Session session: sessionPools.values()) {\n            try {\n                sendMessage(session, message);\n            } catch(Exception e){\n                e.printStackTrace();\n                continue;\n            }\n        }\n    }\n\n    //错误时调用\n    @OnError\n    public void onError(Session session, Throwable throwable){\n        System.out.println(\"发生错误\");\n        throwable.printStackTrace();\n    }\n\n    public static void addOnlineCount(){\n        onlineNum.incrementAndGet();\n    }\n\n    public static void subOnlineCount() {\n        onlineNum.decrementAndGet();\n    }\n\n}\n```\n\n#### 前端页面\n\n```html\n<!DOCTYPE html>\n<br lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<!--<input type=\"text\" placeholder=\"channelId\" id=\"channelId\">\n<input type=\"button\" value=\"连接\" onclick=\"link()\">\n<input type=\"button\" value=\"关闭\" onclick=\"close()\">-->\n\n<input type=\"text\" placeholder=\"\" id=\"sendText\">\n<input type=\"button\" value=\"发送数据\" onclick=\"send()\">\n</br>\n<textarea id=\"txa\" rows=\"10\" cols=\"30\">\n</textarea>\n<body>\n\n</body>\n<script>\n    var ws\n    var timer\n    function send() {\n        var sendId = \"客户端\";\n        var text = document.getElementById('sendText');\n        var txa = document.getElementById('txa');\n        console.log(text.value);\n        txa.value =txa.value + sendId+\":\"+ text.value + \"\\n\";\n        ws.send(text.value);\n    }\n\n    // 打开一个 web socket\n    ws = new WebSocket(`ws://localhost:8080/webSocket/1`);\n\n    ws.onopen = function () {\n        console.log(\"连接完成，可以发送数据\");\n        // 固定频率发送消息保持连接在线\n     /*   timer = setInterval(() => {\n            ws.send(Date.now())\n        }, 10000)*/\n    };\n\n\n\n    ws.onmessage = function (evt) {\n        var received_msg = evt.data;\n        console.log(\"数据已接收...\");\n        console.log(received_msg)\n    };\n\n    ws.onclose = function () {\n        // 关闭 websocket\n        console.log(\"连接已关闭...\");\n    };\n\n    ws.onerror = function (err) {\n        console.error(err)\n    }\n\n    function close() {\n        if (ws === null || ws === undefined) {\n            alert(\"请先连接\")\n        }\n        ws.close()\n        if (!timer) {\n            alert(\"请先连接\")\n        }\n        timer.clear()\n    }\n</script>\n\n</html>\n```\n\n### 微服务架构下session处理\n\n　　由于WebSocket是有状态的，当前端与某个服务节点连接上后，只能与该节点进行通信。session也不能通过外部缓存，那么如果需要发送消息给某个用户，怎么找到用户所连的节点呢？\n\n#### 定向分配\n\n　　通过redis存储用户与连接节点的映射，当需要发送时，该路由表发送到真实节点，节点再转给用户。适合大型架构，精准投放消息。\n\n#### MQ广播\n\n　　使用MQ的订阅模式，所有服务节点订阅相同的主题，需要发送消息时，进行广播，节点收到消息后判断用户是否在自己的节点上，在则发送消息。这种方式适合小型架构。\n\n### 引入RabbitMQ订阅推送消息\n\n　　RabbitMQ的模型有生产者、交换机、消费者，主要有三种模式，Direct、Topic、Fanout模式\n\n* Direct模式\n\n  发送到DirectExchange的消息转发到RouteKey制定的Queue，RouteKey需要完全匹配。\n\n* Topic模式\n\n  根据通配符发送到相应的队列。\n\n* Fanout模式\n\n  广播模式，绑定到交换机上的队列都会收到消息。\n\n#### 实现的功能点\n\n　　WebSocket的中继节点会有多个，我们希望的是每个中继节点订阅队列，消费同一批消息，将消息发送到当前节点的用户上。这里采用RabbitMQ的Fanout模式，随机生成多个队列名称绑定到同一个交换机上，该交换机上所有队列都能收到消息。\n\n![架构图](/assets/blog_img/消息推送.png)\n\n**RabbitMQ配置类**\n\n```java\n@Configuration\npublic class FanoutRabbitConfig {\n\n    /**\n     *  每个节点创建随机队列\n     *  将三个队列都绑定在交换机 fanoutExchange 上\n     *  因为是扇型交换机, 路由键无需配置,配置也不起作用\n     */\n\n    @Bean\n    public Queue queueRandom() {\n        //可直接根据本机ip生成队列名\n        String queueName=\"random\"+ 2;\n        return new Queue(queueName);\n    }\n\n    @Bean\n    FanoutExchange fanoutExchange() {\n        return new FanoutExchange(\"messageFanoutExchange\");\n    }\n\n    @Bean\n    Binding bindingExchangeA() {\n        return BindingBuilder.bind(queueRandom()).to(fanoutExchange());\n    }\n\n}\n```\n\n**消费者**\n\n```java\n@Slf4j\n@Component\npublic class MessageConsumer {\n\t\t//直接关联交换机名称，消费其中一条随机队列\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n            exchange = @Exchange(value = \"messageFanoutExchange\", type = ExchangeTypes.FANOUT)\n    )\n    )\n    public void process(String payload) {\n        log.info(\"receive:{}\", payload);\n    }\n}\n```\n\n### 消费幂等性\n\n​        发送前进行入库，并且设置对应的消费状态；消费端也要判断是否存在该数据，存在且未消费则消费，否则丢弃。\n\n### 消息发送确认机制\n\n　　发送到exchange中会有个回调方法，可以在里面记录数据状态\n\n### 消费确认机制\n\n　　在消费端做了捕获，如果失败设置channel.basicNack(tag, false, true)，消息重新入队\n\n###　消息重新投递\n\n　　可以采用定时任务重新投递消息，引入重试机制\n\n### \n\n","tags":["技术学习","WebSocket"]},{"title":"gitflow实践","url":"/2019/11/11/GitFlow实践/","content":"\n> 团队中使用git来做版本管理，为尽可能贯彻gitflow的实践，做个总结\n\n### 提交代码原则\n\n- 提交的粒度是一个小功能点或一个bugfix\n- comment简练且描述清楚修改的位置或增加的功能\n- 尽可能几次提交再进行一次推送\n\n### GitFlow\n\n- master——最为稳定功能最为完整的随时可发布的代码；\n- hotfix——修复线上代码的 bug；\n- develop——永远是功能最新最全的分支；\n- feature——某个功能点正在开发阶段；\n- release——发布定期要上线的功能。\n\n**Master和develop需要保护起来，只有项目负责人可以推送和删除。**\n\n#### 开发阶段\n\n​\t从develop拉取一条feature的新分支出来进行开发\n\n#### 完成开发阶段\n\n​\t在develop合并feature分支，创建release版本分支，发布测试环境。相关bug问题都在release分支修改，没问题后发布master分支\n\n#### clear阶段\n\n​\t删除feature、release分支\n\n#### 生产环境bug处理\n\n​\t在master上创建hotfix分支，修改代码直接推，然后记得将hotfix分支合并到develop再删除hotfix，原则上要保证develop上的代码是最新的。因为在并行开发的阶段会有多种情况涉及对生产环境等代码的提交，而实践中开发人员很多时候没有定时更新feature分支，导致后面合并的时候将生产代码给覆盖了，引发生产问题\n\n"},{"title":"装饰器模式","url":"/2019/07/26/装饰器模式/","content":"\n**定义**\n\n>用于向一个现有对象添加新的功能，同时不改变其现有结构。通过创建一个类的装饰类，包装原有类，并保证原有类的签名的前提下提供额外功能。\n\n**为什么及什么时候应用**\n\n> 一般拓展一个类的功能会先想到使用继承的基础上添加，但那样会对原有类的层级结构增添多个子类，且往往我们的需求仅仅是针对某个类做一下简单的功能拓展，而并不是为了定义一个新的子类。此时仅仅增加一个装饰类即可。\n\n**优点**\n\n> 装饰类和被装饰类能独立发展，不相互耦合。装饰模式是继承的一个替代，可以动态扩展一个实现类的功能。\n\n<!--more-->\n\n![](/assets/blog_img)\n\n**代码**\n\n**被装饰类接口**\n\n```java\npublic interface Shape {\n   void draw();\n}\n```\n\n**被装饰类具体实现**\n\n```java\npublic class Rectangle implements Shape {\n \n   @Override\n   public void draw() {\n      System.out.println(\"Shape: Rectangle\");\n   }\n}\n\npublic class Circle implements Shape {\n \n   @Override\n   public void draw() {\n      System.out.println(\"Shape: Circle\");\n   }\n}\n```\n\n**装饰类抽象接口**\n\n```java\npublic abstract class ShapeDecorator implements Shape {\n   protected Shape decoratedShape;\n \n   public ShapeDecorator(Shape decoratedShape){\n      this.decoratedShape = decoratedShape;\n   }\n \n   public void draw(){\n      decoratedShape.draw();\n   }  \n}\n```\n\n**装饰类具体实现**\n\n```java\npublic class RedShapeDecorator extends ShapeDecorator {\n \n   public RedShapeDecorator(Shape decoratedShape) {\n      super(decoratedShape);     \n   }\n \n   @Override\n   public void draw() {\n      decoratedShape.draw();         \n      setRedBorder(decoratedShape);\n   }\n \n   private void setRedBorder(Shape decoratedShape){\n      System.out.println(\"Border Color: Red\");\n   }\n}\n```\n\n**客户端**\n\n```java\npublic class Client {\n   public static void main(String[] args) {\n \n      Shape circle = new Circle();\n      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());\n      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());\n      //Shape redCircle = new RedShapeDecorator(new Circle());\n      //Shape redRectangle = new RedShapeDecorator(new Rectangle());\n      System.out.println(\"Circle with normal border\");\n      circle.draw();\n \n      System.out.println(\"\\nCircle of red border\");\n      redCircle.draw();\n \n      System.out.println(\"\\nRectangle of red border\");\n      redRectangle.draw();\n   }\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"适配器模式","url":"/2019/06/23/适配器模式/","content":"\n> 将一个类的接口转换成客户端希望的接口，通常用于使用现有类适配新的系统接口。优点是复用现有类。\n\n> 代码层面：适配器类继承或依赖已有的对象，实现想要的目标接口。\n\n| 组成       | 关系                     | 作用                     |\n| ---------- | ------------------------ | ------------------------ |\n| 客户接口   | 适配的接口               | 客户端想要的接口形式     |\n| 现有目标类 | 现有的可被复用的类       | 提供现有接口实现         |\n| 适配器类   | 实现目标接口，依赖目标类 | 实现目标接口，做接口兼容 |\n\n<!--more-->\n\n![UML](/assets/blog_img/适配器模式.png)\n\n**客户接口**\n\n```java\nabstract class Player{\n\tvoid play();\n}\n```\n\n**目标类**\n\n```java\nclass RgbPlayer{\n\tpublic void specialPlay(){\n    //自有实现方法；\n  }\n}\n```\n\n**适配器类**\n\n```java\nclass PlayerAdapter extends RgbPlayer implements Player {\n  //也可以通过对象依赖的方式注入\n  //private RgbPlayer rgbPlayer;\n  \n\tpublic void play(){\n    //转换并调用目标类的方法,比如换参数\n    this.specialPlay();\n  }\n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n    public static void main(String args[]){\n      Player p = new PlayerAdapter();\n      p.play();\n    }\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"List遍历过程remove的ConcurrentModificationException","url":"/2019/05/03/List遍历过程remove的ConcurrentModificationException/","content":"\n```java\nArrayList<Integer> list = new ArrayList<Integer>();\nlist.add(2);\nIterator<Integer> iterator = list.iterator();\nwhile(iterator.hasNext()){\n  Integer integer = iterator.next();\n  if(integer==2)\n    list.remove(integer);\n}\n```\n\n　　以上代码List在遍历的过程中，通过判定索引，移除List的元素，程序抛出ConcurrentModificationException异常。\n\n**原因**　　\n\n　　在迭代器的实现中，checkForComodification()方法会检查List的modCount与expectedModCount的值，不相等则抛出该异常。我们调用的是List的remove方法， 可以看到程序修改了modeCount的值，但是没有修改expectedModCount的值，导致问题的产生。modCount表示List被修改的次数，expectedModCount表示期待值。\n\n**List的remove方法**\n\n```java\npublic E remove(int index) {\n  rangeCheck(index);\n\n  modCount++;\n  E oldValue = elementData(index);\n\n  int numMoved = size - index - 1;\n  if (numMoved > 0)\n    System.arraycopy(elementData, index+1, elementData, index,\n                     numMoved);\n  elementData[--size] = null; // clear to let GC do its work\n\n  return oldValue;\n}\n\n```\n\n**迭代器的遍历实现**\n\n```java\npublic E next() {\n    checkForComodification();\n    int i = cursor;\n    if (i >= size)\n        throw new NoSuchElementException();\n    Object[] elementData = ArrayList.this.elementData;\n    if (i >= elementData.length)\n        throw new ConcurrentModificationException();\n    cursor = i + 1;\n    return (E) elementData[lastRet = i];\n}\n\nfinal void checkForComodification() {\n    if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n}\n```\n\n**解决方案**\n\n　　调用iterator的remove方法取代List的remove方法， 该方法多了一步操作，expectedModCount=modCount。\n\n```java\npublic void remove() {\n  if (lastRet < 0)\n    throw new IllegalStateException();\n  checkForComodification();\n\n  try {\n    ArrayList.this.remove(lastRet);\n    cursor = lastRet;\n    lastRet = -1;\n    expectedModCount = modCount;\n  } catch (IndexOutOfBoundsException ex) {\n    throw new ConcurrentModificationException();\n  }\n}\n```\n\n","tags":["技术学习","Java基础","异常"]},{"title":"责任链模式","url":"/2019/03/24/责任链模式/","content":"\n> 用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会根据匹配条件处理事务，处理完就根据实际业务需求传递给下一个节点或者返回。\n\n| 组成           |\n| -------------- |\n| 抽象责任处理类 |\n| 请求类         |\n| 具体节点处理类 |\n\n<!--more-->\n\n![UML](/assets/blog_img/责任链模式.png)\n\n**抽象责任处理类**\n\n```java\nabstract class AbstractLeaveHandler{\n   /**直接主管审批处理的请假天数*/\n    protected int MIN = 1;\n    /**部门经理处理的请假天数*/\n    protected int MIDDLE = 3;\n    /**总经理处理的请假天数*/\n    protected int MAX = 30;\n\n    /**领导名称*/\n    protected String handlerName;\n\n    /**下一个处理节点（即更高级别的领导）*/\n    protected AbstractLeaveHandler nextHandler;\n\n    /**设置下一节点*/\n    protected void setNextHandler(AbstractLeaveHandler handler){\n        this.nextHandler = handler;\n    }\n\n    /**处理请假的请求，子类实现*/\n    protected void handlerRequest(Request request){\n\n    }\n}\n```\n\n**请求类**\n\n```java\nclass Request{\n  public Request(int type){\n    this.type=type;\n  }\n  /**类型*/\n  private int type;\n}\n```\n\n**组长处理类**\n\n```java\nclass GroupManagerHandler extends AbstractLeaveHandler {\n\t\n  public GroupManagerHandler(String handlerName){\n    this.handlerName=handlerName;\n  }\n  \n  protected void handlerRequest(Request request){\n    if(request.getType = this.MIN){\n      System.out.println(\"组长处理结束\");\n      return;\n    }\n\n    if(null != this.nextHandler){\n      this.nextHandler.handlerRequest(request);\n    }else{\n      System.out.println(\"审批拒绝！\");\n    }\n  }\n  \n}\n```\n\n**部门经理处理类**\n\n```java\nclass DeptManagerHandler extends AbstractLeaveHandler {\n\t\n  public DeptManagerHandler(String handlerName){\n    this.handlerName=handlerName;\n  }\n  \n  protected void handlerRequest(Request request){\n    if(request.getType = this.MIDDLE){\n      System.out.println(\"部门经理处理结束\");\n      return;\n    }\n\n    if(null != this.nextHandler){\n      this.nextHandler.handlerRequest(request);\n    }else{\n      System.out.println(\"审批拒绝！\");\n    }\n  }\n  \n}\n```\n\n**CTO经理处理类**\n\n```java\nclass CtoManagerHandler extends AbstractLeaveHandler {\n\t\n  public CtoManagerHandler(String handlerName){\n    this.handlerName=handlerName;\n  }\n  \n  protected void handlerRequest(Request request){\n    if(request.getType = CTO.MAX){\n      System.out.println(\"CTO处理结束\");\n      return;\n    }\n\n    if(null != this.nextHandler){\n      this.nextHandler.handlerRequest(request);\n    }else{\n      System.out.println(\"审批拒绝！\");\n    }\n  }\n  \n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n  public static void main(String args[]){\n    GroupManagerHandler g = new GroupManagerHandler(\"组长处理类\");\n    DeptManagerHandler d = new DeptManagerHandler(\"部门经理处理类\");\n    CtoManagerHandler c = new CtoManagerHandler(\"CTO处理类\");\n    g.setNextHandler(d);\n    d.setNextHandler(c);\n\n    Request rq=new Request(30);\n    g.handlerRequest(rq);\n  }\n}\n```","tags":["技术学习","设计模式"]},{"title":"处世","url":"/2018/07/13/处世/","content":"\n>　　当我们做一件事情的时候，不要寐心，可能很多时候为了达成目的，我们会着急，焦虑，眼看时间一点点在消逝，不得已而为之，未考虑清楚匆忙决定一件事情，最终发现事与愿违。当然太过谨慎思虑太多也会错失很多机会，青春给了我们试错的资本，敢于尝试是听得比较多的道理。\n>\n>　　对人对事，得与失之间，权衡利弊而后之。而立之年，太多的困惑会阻挡人的前进方向，选择的方向往往比努力重要，想成为什么样子，想达到什么目标，三思而后行。我们处在一个环境中往往会带有局限性，限制我们的视野与思维，当你慢慢接触更优秀的人与其共事交流，会开阔自身的思维与境界，很多时候我们更愿意处于一个舒适区，不想跳出来，害怕这份稳定与安宁被打破，宁愿在内做最优解，但是这样人就会不知不觉被环境所同化，带有其土壤所熏陶的气息，很难打破。如果我们选择的东西不是我们内心所想要的，必定有所困惑，怀疑自身的态度与原则，必要的调解都无法按捺内心那股冲突。我们处于世上，有着自身的底线，跨越这个底线，抛弃原则，可能最终自己都无法认清自己的模样，何苦呢？\n>\n>　　人必要忠于自己而后立生处事，对人对事亦然。","tags":["理哲"]},{"title":"表我与自我","url":"/2018/07/09/表我与自我/","content":"\n> 　　当我们认知一个人，最快速的方式是通过外表，穿着，走姿，来刻画一个人在我们心目中的印象，标签化是我们短期内记忆一个人最快的方法，反之亦然。\n>\n> 　　一个人所呈现的表象是他想让我们看到的样子，表我和内我是截然不同的，在外界环境中，起作用的是表我，这个姿态是我们根据社会规则，道德伦理，他人所要求的样子所刻画出来的。形成一个人的表我，其行为细节，三观，态度等，其实都可以关联性分析。一个人最原生的自我来自于其原生家庭，所处的阶层，父母的教养，童年的经历，青春期的成长，都是塑造一个人的基石。其三观与原生家庭的教养会在社交细节中体现出来，其行为动机则需要关联构成其复杂性格的环境与经历。我们知道一个人的行事总是遵循其固定不变的性格构成，受动机和能力的制约，一个正常的人在其范围内作出的行为都是有根据的，处事，对人亦然。要了解一个人的自我，需要时间去了解，通过对其日常的行为细节，观其言察其色，对待一件事情的反应，面对责任时是推卸抑或主动承担。这些细节是掩饰不了的，会在其行为中体现出来。情商达练之人懂得在人群中把握分寸，与人相处时保持一种舒适的状态，适度展现自我在环境中的存在，但也往往成为其弱点。人与人相处时，其一言一行都会进入他人的印象中，言语是其动机产生的结果，达到一个如何的程度，希望事情走向一个什么样的结果，其实已经刻画在一个人的大致计划中，是其本我在事物发展过程当中的本能调控。这类动机行为是难以看穿的，因为当你不完全了解一个人时，这个结果你是无法推敲出来的。有一类人，处于人群中并不处于起眼的，但发生某事情时，为了调控事情走向，达到自我目的，会通过各类细节去调控，虽然抽象，但是若果最终的结果如他个人所愿，则必定有其达练之处。聪明人与聪明人交谈时，思维方式是跳跃的，正常人的交流顺序是按照123456，但聪明人之间交流的逻辑顺序是136，遵从跳跃式顺序。很多时候聪明人识破一个人的动机的时候，不会去揭穿，鉴于正常的社交尊重，让对方能够下台面或者利用话题周旋，若这个动机也是能够接受的范围内，且是双赢的，则会顺应对方的所求，有所求必有所图，这类人难以交心，其有着天生的防备心态，表面上关系融洽，但一旦希望关系深入时，你必然能感受到与对方的距离。大智若愚非常适用于形容高阶的聪明人，看似平淡无常，其背后的动机暗流涌动，当你对其产生疑惑但又无法说出个所以然来，这时候，明显的对方已经高你一阶。\n\n","tags":["理哲"]},{"title":"光阴似箭日月如梭","url":"/2018/07/07/光阴似箭日月如梭/","content":"\n>　　光阴似箭，日月如梭，曾几何时写作文惯用的起手式只是应付当时那800字的心态加之自身时常慨叹时光易逝，因此，这两个四字词不知出现在我的作文里多少次。再次用起，总有一番不同的感觉。很多电影，很多文章，很多诗词，很多字句，当人有了一定的阅历后重新回味总会有一番不同的感受，如周星驰的电影，宫崎骏的动漫，童年1元杯的珍珠奶茶，街边小贩的牛杂，初高中写的文章，这种五味杂陈的感觉或许就是自身心智在不断成熟，对过去自我一种审视的反馈。不知不觉时间已到了2018，偶然间被叫了声叔叔犹感突兀，但貌似在提醒我已长大成人，95后的我们已经奔向社会，成为承担社会责任的一代，起承转合间备感压力，爱情婚姻，事业家庭，属于这个阶段去追求的东西，人生没有多少个十年，一个阶段又一个阶段的成长造就现在的我们，不断变化的自我与环境间的不断磨合，年轮棱角在角逐中被磨平，因此能够保持初心的人犹应珍惜。那一个个头顶掉发的中年大叔当年何不是意气风发的青年，带着梦想与期待步入社会，在生活面前，他们收起了那份锐气取而代之的是对生活的妥协，这或许是一种成熟吧，我不知道，但是自我抗拒成为他们，因此必须储备资本，你才有条件对生活说不，这个条件需要你为之付出，付出才有所得，任何事情亦然，空有目标而无执行力只是头脑发热之人的一时冲动，落实到逐步的目标实施中，有具体的可行性，才有机会达到想要的效果。\n>\n>　　勤奋的含义是今天的热血，而不是明天的决心，后天的保证。","tags":["理哲"]},{"title":"存在即是合理","url":"/2018/07/04/存在即是合理/","content":"\n>　　存在即是合理，当环境变换时，周遭的一切都不是你知悉的一切，快速投入到工作中，你会发现周围的一切都那么模糊，快速的工作节奏，工作的deadline压力，抬头发现已经忘记时间，夜色已经降临，只是生活还是在继续。走出大楼，那各色的人匆匆茫茫到底在奔向何方，憧憬着什么。有时你会发现人最可怕的地方是不知道自己想要什么，任由生活摆布。但成年人的世界有时又无可奈何，责任在身，上级的压力，慢慢的就能够去接受，去承担这种变化，无事一身轻或许是最潇洒的状态，摆摆手或者就能让自己的生活轻松点，但是人要懂得居安思危，时间是很残酷的，不知不觉你的青春、你的时间就已然流逝。\n>\n>　　生活要有点盼头，有点目标，你就会去期待，这个过程必须改变自我，坚持着一些事情，养成良好的习惯，保持自律，一点一点的积累，相信会在不久的将来收到回报。","tags":["理哲"]},{"title":"杂谈","url":"/2018/06/29/杂谈/","content":"\n>　　成长，爱情，婚姻，可能是20多岁这个年龄段比较苦恼的三件事情，一方面我们步向社会，慢慢适应社会的节奏，从学生到社会一员这一角色的转变，带着金字塔尖那份骄傲走出来，发现这份骄傲带给你的只有一时的光环作用，社会更看重个人价值，能力贡献，说白了就是等价交换，不管是技能、资本、人脉抑或其他可利用的资源，都被他人当作你的价值所在，你身上会自带一个标签，大家会利用那个标签来评判你的利用价值，这些都在人际交往的细节中能体现出来，社交就是一种互利互惠的活动，标签化印象化是你能给与他人对你认知最快的方式。在社会中不再像学生阶段般，大家都是平等地接受教育，学习，考试，以成绩来定论一个人。不得承认好多在校成绩优秀的学生进入社会会有一份失落感，不再以成绩来定论一个人的价值，而是多方面的能力，这能力是个笼统的概念，也即是如上所说，不再是你个人产生的影响，涉及到各个层面的关系，利用好这各方面的资源，对于个人的发展有各种好处。\n>\n>　　关于爱情，私以为触不可及，也不算，只不过在遇到适合的人之前都不愿随便发展一段感情，毕竟爱情需要成本，不管感情上、精力上抑或经济上，很多时候，上层建筑是需要下层建筑来支撑的，这一点在初中政治课上早有认知，爱情亦然，这个社会越来越不相信爱情，讲究门当户对，高中课上年过半百的数学老师直言道，但我们不以为然，我们相信着那没有面包的爱情，纯真动人，可以为了爱不顾一切。但随着成长，你会发觉这个世界很不公平，爱情是一件很奢侈的东西，见过一些人和事，发现爱情有时不堪一击，那般脆弱，因为我们身处这个大环境中，我们的观念，视角不再受那书中狭隘的爱情观所枷锁，欲望在膨胀，观念在刷新，影响着我们的选择，我们的考虑。但不管如何，谁都享有爱情的权利，既然两情相悦，惺惺相惜，那就去体验吧，至少不会成为人生的一大遗憾。\n>\n>　　关于婚姻，常听说婚姻是爱情的坟墓，貌似爱情的终点就是婚姻，成为枷锁两个人一生的苦链，我无法评判先辈的经验之谈，未到那个年纪未有那般体会也不好说什么。但至少我是向往婚姻的，婚姻应该是两个人爱情的结晶，是对彼此相依为命，厮守终生的一种承诺，未来的事情我们不能预测与知晓，但我们在那一刻的选择就是我们那一刻所相信着的想法，既然相信着那就相信自己的选择，一起去面对生活的柴米油盐，面对生活的欢声笑语。生活不可能永远一帆风顺，婚姻也如此，任何一段成功的婚姻无不是两个人共同参与，共同构建的结果，这其中的酸甜苦辣也只有你们两个知道，正是一起走过，一起面对，齐步并进，婚姻才会幸福而美满，只向往美好而不考虑艰辛，只憧憬快乐而忽视痛苦，那是自私者的想法 ，爱与被爱都是相互的，好的婚姻应当是相互扶持，相互关爱，包容理解，所以见到一些老年后依然彼此关爱，互相尊重的夫妻，才会感叹好的婚姻的难能可贵，因为生活的重担很容易消耗感情，消耗彼此的耐心，一旦风雨来临，就能见证婚姻的坚固性。\n>\n>　　杂谈629","tags":["生活"]},{"title":"写","url":"/2018/06/28/写/","content":"\n>　　写，是一种心情，是一种态度，是对生活的思考，庆幸我生而为人，庆幸我学会了读与写，庆幸我有了思想，只需要一支笔，一个大脑便能对抗全世界，对抗消极的一切。当你有了写的冲动，那抑制不住的倾诉欲，涌现的灵感，流露的情绪只需执笔下纸。那文字是你面对生活的武器，是你激荡的思考留下的结晶，是你迸发的心情，是你不屈的态度，想写就写，有想法就写，多么惬意舒适，自由自在。你升华着，成长着，什么都无法阻挡枷锁你自由的思想，任其倾泻吧，那是你生活源源不断的动力，是面对困难的武器，是面对消极的解药。\n>\n>　　给我一支笔，一个自由的思想，我不再畏惧。","tags":["生活"]},{"title":"平常心","url":"/2018/06/27/平常心/","content":"\n>　　世上有一些东西，是你自己支配不了的，比如运气和机会、舆论和毁誉，那就不去管它们，顺气自然吧！\n>\n>　　世上有一些东西，是你自己可以支配的，比如兴趣和志向、处世和做人，那就在这些方面好好地努力，至于努力的结果是什么，也顺气自然吧！\n>\n>　　我们不妨去追求最好——最好的生活、最好的职业、最好的婚姻、最好的友谊，等等。但是，是否得到最好，取决于许多因素，不是光靠努力就能成功。因此，如果我们尽了力，结果得到的不是最好，而是次好、次次好，我们也应该坦然地接受。人生原本就是有缺憾的，在人生中需要妥协。不肯妥协，和自己过不去，其实是一种痴愚，是对人生的物质。\n>\n>　　在青年时期，人有虚荣心和野心是很正常的。成熟的标志是自我认识，认清了自己的天赋方向，于是外在的虚荣心和野心被内在的目标取代。\n>\n>　　野心倘若肯下降为平常心，同时也就上升成了慧心。","tags":["理哲"]},{"title":"困顿与觉悟","url":"/2018/06/24/困顿与觉悟/","content":"\n>　　人生的困惑无非色与空，色代表情感的困惑，空代表生命意义的困惑。想来想去，到头仍是困惑。不过想的好处是，在困惑中有了方向，困惑中的寻求形成了人的精神生活。因为色的诱惑，男人走向女人，女人走向男人，走进彼此的心灵，有色入情，于是有了爱。因为空的疑惑，人类呼唤世界之本相，由空入悟，于是有了哲学和宗教。\n>\n>　　不去想人生的大问题，不是会快乐点吗？不是因为思考所以痛苦，而是因为痛苦所以思考。想不想不是自己能选择的，由天生的禀赋决定。想这类问题的人多半生性敏感而认真，实在身不由己，欲罢不能。\n>\n>　　喜欢想人生问题的人，所谓喜欢想，并不是刻意去想，而是问题自己找上来，躲也躲不掉。想这类问题当然痛苦，但痛苦在先，你不去思考，痛苦仍然在，成为隐痛。既然如此，不如去面对它，看一看那些有智慧的人是怎么想这类问题的，开阔自己的思路，把痛苦变成人生的积极力量。","tags":["理哲"]},{"title":"存在的意义","url":"/2018/06/24/存在的意义/","content":"\n> 　　每个人生于世上，都不免会对自己存在的意义产生疑惑。不知何时有了意识，对这个世界有了清晰的认知，当问起自己这个问题时，仿佛呱呱落地的我们就在昨天，但今日我们已成为这个世界整体的一部分，不可否认的存在着。对于世界来讲，人是客体，对于人来讲，这个世界的一切都是客体。人作为一种有思考能力的动物，在进化的过程中区别与其他生物，我不免有疑惑我们的思维方式是否受限于我们的物质构成，如果将整个世界，扩大至宇宙，我们也不过是时间长河的一瞬，空间上的一点尘埃。换个角度，人不是这个世上的主体，也不过如其他物质，生物那般只是这个有机世界的一部分，以世界作为主体的角度来看，人与其他一切客体都是等同的，无非就是分子在不断运动，产生，分化，死亡。无他，也就是物质的形态以一种方式产生凋零转化为另一种形态。\n>\n> 　　每个人终其一生的寿命十分短暂，但走过的轨迹都是唯一的，认识的人经历的事情，我们身处这个时代，也受制于这个时代，我们享受着21世纪的便利，也遵循着社会运行法则，在这个车轮不停滚动的社会中生存，作为一种有思想的生物，我们接受的教育一方面完善我们的认知，但不可否认，一方面抑制了我们的思维。我们的三观，父母、老师的教育这些潜移默化的观念在我们青年时期已然写入我们的生命中，认知了世界的运行法则，然后在此之上，在生存着抑或有着各式各样的梦想，在个体生命中不断追逐。我们按照这个世界的规律，受教育，成长，工作，结婚，生子，退休，死亡，千篇一律，可能是每个人的轨迹路线了。\n>\n> 　　其实，对于每个个体来讲，体验一遍生命我认为就是其存在的意义，不管如何，这个世界有你存在的痕迹，到过，经历过，了解过，何其不是一种幸运，不管出生前的你处于什么，死亡后的你处于什么，你在这个起点与终点之间走过了一段路，感受自我与周遭世界的一切，那便是对于个体来讲存在的最大意义，放平心态，去感受生命的美好，感受世界带给你的风景，是我们作为人来讲最幸运的一种能力了。\n\n","tags":["理哲"]},{"title":"我们对待自己的态度","url":"/2018/06/24/我们对待自己的态度/","content":"> 　　一个人的个性越独特、越具价值和意义，那么，他就越有必要不时地认清自己生命总体发展的大致脉络和自己的计划，为此必须要踏上认识自己的道路，清楚自己的首要和真正的意愿——这些对于他的幸福而言是至关重要的东西，然后对于何者排在第二和第三位置必须心中有数。同时他也应该大致明白自己应该从事何种职业、需要扮演何种角色以及自己与这个世界的关系。如果一个人具备非凡的个性，那么，对自己的生命计划有一个大致的了解，能够比任何一切都更有效地增强自己的勇气，振作、鼓足信心，激励自己行动起来，避免走弯路。\n>\n> 　　只有登上峰顶才能够回头总体，连贯的看到自己所走过的迂回曲折的道路，同样，只有当我们度过了生命中的一段时间，或者在我们整体生命终结的时候，我们才能把我们做的事、业绩真正联系起来，包括其中的因果关联，甚至才能了解到它们的价值。只要我们置身其中，那我们的行事就只能总是遵循我们那固定不变的性格构成，受着动机的左右和我们能力的制约。由此可见，我们的行事自始至终都有其必然性。我们在每一刻都做着我们在那一刻认为合理和适当的事情，只有事后的结果才让我们看清到底发生了什么事；对事情整体的惠顾才使我们明白事情的如何和为什么。\n>\n> 　　人生的智慧的重要一点就是在关注现在和计划将来这两者之间达致恰到好处的平衡，这样，现在与将来才不至于互相干扰。许多人太过沉迷现在，这些是无忧无虑、漫不经心的人；也有的人则更多地活在将来，他们则是谨小甚微、忧心忡忡的杞人。人们很少能够在处理现在和将来两者当中把握一个恰到好处的尺度。那些以希望和努力生活在将来的人眼睛盯着前面，不耐烦地等待将要发生的事情，仿佛将来的事情才会为他们带来真正的幸福。在这期间，他们却对现在不予理会、不加咀嚼，听任现时匆匆逝去。\n>\n> 　　我们应该愉快地迎接现时此刻，从而有意识地享受每一可忍受的、没有直接烦恼和痛苦的短暂时光，也就是说，不要由于在过去我们的希望落空现在就变得忧郁寡欢，或者为了将来操心伤神以致和败坏现时。\n>\n> 　　对已经发生的\n>\n> 　　无论事情多么悲痛，我们必须让过去的事情成为过去，或许我们难以做到这一点，但我们必须降伏我们的乖僻心情。\n>\n> 　　对将来的事情\n>\n> 　　在上帝的安排之中。\n>\n> 　　应该把每一天都视为一段特别的生活。\n>\n> 　　我们只能为那些肯定发生的灾祸忧心，对于不可肯定的，我们必须养成习惯，把并不肯定发生的灾祸视为永远不会发生。\n>\n> 　　我们的安宁越少受到担忧和害怕的打扰，那它就越会被我们的愿望、欲念和期待所刺激。只有当人挣脱了所有各种可能的期望，从而返回赤裸和冰冷的存在本身，人才能领会到精神上的安宁，而精神的安宁却是幸福的构成基础。如果人要享受现时，乃至整个一生，精神的安宁是必不可少的。我们应该永远记住今天只有一次，它不会再来。但在我们的想象中，今天又在明天重现。其实明天又是另外的一天，它也只来一次。在我们患病、困顿的时候，每当念及在这之前没有疾病和痛苦的时光，就陡然让人心生羡慕——那些美好的日子就犹如不曾得到我们珍惜的朋友，它们简直就是失去了的天堂。在健康、美好的日子里，这种情形应被我们牢记在心，这样我们就会倍加珍惜和享受此刻的好时光。\n>\n> 　　我们的视线、活动和接触的范围越狭窄，我们就越幸福；范围圈子越大，我们感受的焦虑或者担忧就越多。因为随着这一范围圈子的扩大，我们的愿望、恐惧、担忧也就相应增加。痛苦是肯定的，幸福是否定的。我们感受到欢乐还是痛苦，归根到底取决于我们意识的内涵。我们的一生中，我们关系和目标的范围总是不断伸展。在童年时期，我们的视野只局限于周围的环境和狭窄的关系。到了青年，视野明显扩大；进入成年期，我们的整个生命轨迹，甚至最遥远的联系、别的国家和民族都被纳入我们的视线之内；局限制约有助于增进我们的幸福，原因就在于意欲受到的刺激越少，我们的痛苦也就越少。我们的生活关系应尽可能的简单，越少感觉到生活，并因此更少地感觉到生活的重负，重负本来就是生活的本质。这样生活流淌就像一条波澜不惊、旋涡不起的小溪。","tags":["理哲"]},{"title":"缓存与DB数据操作问题","url":"/2018/05/28/缓存与DB数据操作问题/","content":"\n　　更新数据时，先删除缓存再更新DB，还是先更新DB再删除缓存。\n\n#### 先删除缓存再更新DB\n\n　　出现脏数据的概率较大，假设系统存在两条线程，一条是查询，一条是更新，当更新时，先删除缓存，此时查询线程不能命中缓存，去查库，此时load的是旧数据，然后将旧数据缓存，更新线程此时才更新数据库。这样很大的概率缓存是脏数据。\n\n#### 先更新DB再删除缓存\n\n　　产生脏数据的概率低，同样是上个例子两条线程，当更新DB时，查询线程查的是旧数据，此时删除缓存，下次查询则会去查库，保证新数据，不会影响后面的数据。这种情况产生脏数据的情形：查询线程命中不了缓存，去查库，此时更新操作删除缓存，尔后查询线程load旧数据进缓存，这才造成脏数据。出现的条件在于查库线程在更新操作之前，且在更新线程删除缓存之后load数据进缓存。条件比较苛刻，可以忽略。","tags":["技术学习"]},{"title":"外观模式","url":"/2018/05/27/外观模式/","content":"\n**定义**\n\n> 外部与一个子系统的通信通过一个统一的外观对象进行，为一组接口提供一个统一的界面，外部与其只通过这个抽象的接口，隐藏背后的复杂性。\n\n<!--more-->\n\n![](/assets/blog_img/外观模式.png)\n\n**解决场景**\n\n　　一般业务包含一系列复杂的子逻辑，需要调用各个子服务的接口才能完成既定的业务需求，为了让调用方可以透明调用且无需了解其背后的逻辑链路，通过封装一个一致的门面对象，提供必要的接口参数即可。\n\n　　如下单功能，我们需要保存用户的下单记录，发送物流，保存订单这系列操作，我们可以封装一个订单接口，对外提供下单的接口，剩下的逻辑放在其中去做。调用方无需了解。\n\n**代码**\n\n**门面接口**\n\n```java\npublic interface OrderService{\n  void saveOrder();\n}\n```\n\n**门面实现**\n\n```java\npublic class OrderServiceImpl implements OrderService{\n  UserService userService;\n  DistribuService distribuService;\n  void saveOrder(){\n    userService.saveBuyRecord();\n    distribuService.distriPackage();\n  }\n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n  public static void main(String args[]){\n    OrderService service = new OrderServiceImpl();\n    service.saveOrder();\n  }\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"kafka生产重复消费问题","url":"/2018/04/11/kafka生产重复消费问题/","content":"\n> 生产环境中kafka出现消息积压的情况，消费者重复消费的情况\n\n**分析**\n\n业务代码中消费端主要做消息存储与消息推送，http推数据。定位消费端的日志逻辑，发现http连接超时，应该是厂家设的推送地址有问题，导致超时。用的kafka版本是0.10.0，查阅了超时配置在10s，思路就改动消费端的逻辑，改成用线程池去异步推，把自动提交改成手动提交，解决了我的问题。\n\n0.10.0以后的版本与消费者相关的几个重要参数\n\n- enable.auto.commit 默认值true，表示消费者会周期性自动提交消费的offset\n- auto.commit.interval.ms 在enable.auto.commit 为true的情况下， 自动提交的间隔，默认值5000ms\n- max.poll.records 单次消费者拉取的最大数据条数，默认值\n- 500 max.poll.interval.ms 默认值5分钟，表示若5分钟之内消费者没有消费完上一次poll的消息，那么consumer会主动发起离开group的请求\n\n使用0.10.0后的版本，重要的特性是多了个poll线程，一个心跳线程维持心跳，另一个poll线程拉取数据，当消费了拉取的数据后，消费端会重新poll。当超过指定时间没有poll，也即consume*条数>poll的间隔时间就会发生rebalance\n\n","tags":["消息队列"]},{"title":"代理模式","url":"/2018/03/24/代理模式/","content":"\n> 一个类代表另一个类的功能，创建现有对象的对象，向外提供功能接口。增加了中间层，目标对象职责明确，不同的代理类能够按照场景去做不同的额外业务操作，不影响被代理类的业务。\n\n![](/assets/blog_img/代理模式.png)\n\n<!--more-->\n\n**银行接口**\n\n```java\npublic interface Bank{\n  void saveMoney();\n}\n```\n\n**银行业务处理类**\n\n```java\npublic class RealBank implements Bank{\n  void saveMoney(){\n    log.info(\"存款\");\n  }\n}\n```\n\n**银行代理类**\n\n```java\npublic class ProxyBank implements Bank{\n  \n  private RealBank realBank;\n  \n  void riskCaculate(){\n    log.info(\"风险评估\");\n  }\n  \n  void saveMoney(){            \n    riskCaculate();\n    realBank.saveMoney();\n  }\n  \n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n\tpublic static void main(String args[]){\n\t\tBank bank = new ProxyBank();\n\t\tbank.saveMoney();\n\t}\n}\n```\n\n","tags":["技术学习","设计模式"]},{"title":"ssr & ignite 搭建","url":"/2018/02/26/ssr-ignite-搭建/","content":"\n#### shadowsocks安装\n\n```shell\nyum -y update\n\nyum -y install wget\n\nwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n\nchmod +x shadowsocks.sh\n\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n\n> 编辑：vi /etc/shadowsocks.json\n>\n> 启动：/etc/init.d/shadowsocks start\n>\n> 停止：/etc/init.d/shadowsocks stop\n>\n> 重启：/etc/init.d/shadowsocks restart\n>\n> 状态：/etc/init.d/shadowsocks status\n>\n> 卸载：./shadowsocks-go.sh uninstall\n\n#### bbr安装\n\n```shell\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh\n\nchmod +x bbr.sh\n\n./bbr.sh\n\n#确认bbr开启\nlsmod | grep bbr\n\n```\n\n#### SSR安装\n\n```shell\nyum -y install git \nyum --enablerepo=extras install epel-release\nyum -y install python-pip\n\ngit clone https://github.com/hao35954514/shadowsocksR-b.git\n\ncd shadowsocksR-b/ \nbash initcfg.sh\n\nsed -i \"s/API_INTERFACE = 'sspanelv2'/API_INTERFACE = 'mudbjson'/\" userapiconfig.py\n\n```\n\n>使用说明:\n>\n>python mujson_mgr.py -a|-d|-e|-c|-l [选项( -u|-p|-k|-m|-O|-o|-G|-g|-t|-f|-i|-s|-S )]\n>\n>操作:\n>\n> -a ADD        添加 用户\n>\n> -d DELETE      删除 用户\n>\n> -e EDIT       编辑 用户\n>\n> -c CLEAR       清零 上传/下载 已使用流量\n>\n> -l LIST       显示用户信息 或 所有用户信息\n>\n>选项:\n>\n> -u USER       用户名\n>\n> -p PORT       服务器 端口\n>\n> -k PASSWORD     服务器 密码\n>\n> -m METHOD      服务器 加密方式，默认: aes-128-ctr\n>\n> -O PROTOCOL     服务器 协议插件，默认: auth_aes128_md5\n>\n> -o OBFS       服务器 混淆插件，默认: tls1.2_ticket_auth_compatible\n>\n> -G PROTOCOL_PARAM  服务器 协议插件参数，可用于限制设备连接数，-G 5 代表限制5个\n>\n> -g OBFS_PARAM    服务器 混淆插件参数，可省略\n>\n> -t TRANSFER     限制总使用流量，单位: GB，默认:838868GB(即 8PB/8192TB 可理解为无限)\n>\n> -f FORBID      设置禁止访问使用的端口\n>\n>​            -- 例如：禁止25,465,233~266这些端口，那么这样写: -f \"25,465,233-266\"\n>\n> -i MUID       设置子ID显示（仅适用与 -l 操作）\n>\n> -s value       当前用户(端口)单线程限速，单位: KB/s(speed_limit_per_con)\n>\n> -S value       当前用户(端口)端口总限速，单位: KB/s(speed_limit_per_user)\n>\n>一般选项:\n>\n> -h, --help      显示此帮助消息并退出\n>\n>多用户的本地JSON数据库文件位置：shadowsocksR-b/mudb.json\n\n>\n>\n>\\#添加用户\n>\n>python mujson_mgr.py -a -u fuck -p 8989 -k panzer1230 -m aes-256-cfb -O auth_aes128_md5 -G 10 -o tls1.2_ticket_auth -s 10000 -S 10000 -t 10\n>\n>\\#编辑用户\n>\n>python mujson_mgr.py -e -u lightime -t 100 #以用户修改\n>\n>python mujson_mgr.py -e -p 3333 -t 100 #以端口修改\n>\n>\\#删除用户\n>\n>python mujson_mgr.py -d -u lightime #以用户为依据删除\n>\n>python mujson_mgr.py -d -p 3333 #以端口为依据删除\n>\n>\\#其他操作\n>\n>python mujson_mgr.py -l #查看所有用户信息\n>\n>python mujson_mgr.py -l -u lightime #查看单个用户信息(包括流量使用情况)\n>\n>python mujson_mgr.py -c -u lightime #用户使用流量清零\n>\n>\\#服务端控制\n>\n>./run.sh #后台运行 但不记录日志\n>\n>./logrun.sh #后台运行 且 记录日志\n>\n>./tail.sh #查看日志./stop.sh #停止服务端\n\n#### go-ignite\n\n>go-ignite是一个基于Docker实现，由Golang开发的多账户SS(R)管理面板。\n>对用户来说，SS(R)服务被隔离在单独的容器中，安全高效，一键创建服务，简单方便。\n>对管理员，提供后台管理页面，能够快捷的管理用户服务，重置流量等。\n>\n>用户面板：\n>支持创建 SS 和 SSR，但是仅提供自定义加密方式，且只能在初始化激活账号的时候，创建之后无法更改；\n>SS 支持 AEAD 系加密；\n>SSR 密码由随机生成、协议默认 auth_aes128_md5、混淆默认 tls1.2_ticket_auth_compatible。\n>\n>管理面板：\n>无法更改用户端口、服务类型；\n>用户使用的端口并非随机创建。\n>\n>因为需要使用 Docker，所以请使用非 OpenVZ 构架的 VPS 进行。\n\n```shell\ncurl -sSL https://get.daocloud.io/docker | sh\nservice docker start\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.19.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nusermod -aG docker root\n\n```\n\n```\ncd /opt\nvi docker-compose.yml\n```\n\n##### 通过ip访问\n\n```yml\n    version: '3'\n\n    services:\n\n      ignite:\n        container_name: ignite\n        image: goignite/ignite\n        volumes:\n          - \"./data:/root/ignite/data\"\n          - \"/var/run/docker.sock:/var/run/docker.sock\"\n        environment:\n          - HOST_ADDRESS=8.8.8.8\n          # 此处修改为VPS IP，是展示在用户界面上的 SS/R 的连接 IP\n          - HOST_FROM=5001\n          # SS/R 容器的起始可用端口范围，默认 5001\n          - HOST_TO=6000\n          # SS/R 容器的截止可用端口范围，默认 6000\n        ports:\n          - \"80:5000\"\n          # 用户界面访问端口，默认 80\n        restart: always\n\n      ignite-admin:\n        container_name: ignite-admin\n        image: goignite/ignite-admin\n        volumes:\n          - \"./data:/root/ignite/data\"\n          - \"/var/run/docker.sock:/var/run/docker.sock\"\n        environment:\n          - AUTH_USERNAME=admin\n          # 管理员用户名\n          - AUTH_PASSWORD=admin_password\n          # 管理员密码\n          - Auth_SECRET=ignite2017\n          # 生成 JWT Token 的密钥，随便修改\n        ports:\n          - \"8080:8000\"\n          # 管理界面访问端口，默认 8080\n        restart: always\n```\n\n##### 通过域名访问（中文为了说明，使用时请删除）\n\n```yml\n   version: '3'\n\n  services:\n\n    nginx-proxy:\n      container_name: nginx-proxy\n      image: jwilder/nginx-proxy\n      ports:\n        - \"80:80\"\n        # 访问端口，可以无需修改\n      volumes:\n        - /var/run/docker.sock:/tmp/docker.sock:ro\n      restart: always\n\n    ignite:\n      container_name: ignite\n      image: goignite/ignite\n      volumes:\n        - \"./data:/root/ignite/data\"\n        - \"/var/run/docker.sock:/var/run/docker.sock\"\n      environment:\n        - HOST_ADDRESS=8.8.8.8\n        # 此处修改为 VPS IP，是展示在用户界面上的 SS/R 的连接 IP\n        - HOST_FROM=5001\n        # SS/R 容器的起始可用端口范围，默认 5001\n        - HOST_TO=6000\n        # SS/R 容器的截止可用端口范围，默认 6000\n        - VIRTUAL_PORT=5000\n        - VIRTUAL_HOST=domain.com\n        # 用户面板的访问域名\n      restart: always\n\n    ignite-admin:\n      container_name: ignite-admin\n      image: goignite/ignite-admin\n      volumes:\n        - \"./data:/root/ignite/data\"\n        - \"/var/run/docker.sock:/var/run/docker.sock\"\n      environment:\n        - AUTH_USERNAME=admin\n        # 管理员用户名\n        - AUTH_PASSWORD=admin_password\n        # 管理员密码\n        - Auth_SECRET=ignite2017\n        # 生成 JWT Token 的密钥，随便修改\n        - VIRTUAL_PORT=8000\n        - VIRTUAL_HOST=admin.domain.com\n        # 管理面板的访问域名\n      restart: always\n```\n\n```\ncd /opt\ndocker-compose up -d\n\ndocker-compose up -d\n# 运行\ndocker-compose down\n# 停止\ndocker-compose pull\n# 更新\n```\n\n","tags":["ssr","ignite"]},{"title":"vim","url":"/2018/02/14/vim/","content":"\n## 命令模式\n\n**移动光标**\n\n| 按键      | 操作           |\n| --------- | -------------- |\n| h         | 左移动         |\n| j         | 下移动         |\n| k         | 上移动         |\n| l         | 右移动         |\n| ctrl+d    | 下移动半页     |\n| ctrl+u    | 上移动半页     |\n| gg        | 移动到第一行   |\n| G         | 移动到最后一行 |\n| nG        | 移动到第n行    |\n| n+<space> | 右移n个字符    |\n| n+<enter> | 下移动n行      |\n\n<!--more-->\n\n**搜索**\n\n| 按键  | 操作         |\n| ----- | ------------ |\n| /word | 向光标下搜索 |\n| ?word | 向光标上搜索 |\n\n**删除、复制与粘贴**\n\n| 按键 | 操作             |\n| ---- | ---------------- |\n| x    | 向后删除一个字符 |\n| nx   | 向后删除n个字符  |\n| dd   | 删除游标那正行   |\n| ndd  | 删除光标下n行    |\n\n| 按键 | 操作          |\n| ---- | ------------- |\n| yy   | 复制那一行    |\n| nyy  | 复制光标下n行 |\n\n| 按键 | 操作                         |\n| ---- | ---------------------------- |\n| p    | 将已复制的数据贴到光标下一行 |\n| P    | 将已复制的数据贴到光标上一行 |\n\n| 按键   | 操作                   |\n| ------ | ---------------------- |\n| u      | 复原前一个动作（撤回） |\n| ctrl+r | 重做上一个动作         |\n\n**切换到输入模式**\n\n| 按键 | 操作                                 |\n| ---- | ------------------------------------ |\n| i    | 目前光标所在处输入                   |\n| I    | 从光标所在行的非空格字符输入         |\n| a    | 从目前光标所在的下一个字符开始输入   |\n| A    | 从目前光标所在的最后一个字符开始输入 |\n| o    | 从目前光标所在的行的下一行开始输入   |\n| O    | 从目前光标所在的行的上一行开始输入   |\n\n**命令模式切换到底线命令模式**\n\n| 按键          | 操作                           |\n| ------------- | ------------------------------ |\n| :w            | 编辑的数据写入硬盘             |\n| :w!           | 强制写入硬盘，无权限还是写不进 |\n| :q            | 离开vi                         |\n| :q!           | 修改过不想保存，强制离开vi     |\n| :wq           | 保存后离开                     |\n| :w [filename] | 另存为                         |\n\n**vim环境的变更**\n\n| 按键      | 操作         |\n| --------- | ------------ |\n| :set nu   | 显示行号     |\n| :set nonu | 取消显示行号 |\n\n","tags":["技术学习","生产效率"]},{"title":"kafka消息队列","url":"/2018/02/11/kafka消息队列/","content":"\n# 前言\n\n> 在项目中使用到了kafka中间件，作为消费队列，下文对该组件的一些概念和特性做一些概括性总结。\n\n# 消息队列作用\n\n解耦：降低系统间的耦合度，方便日后扩展\n\n削峰：通过异步处理消息，并且提供多消费端来消费消息，达到削峰的作用\n\n冗余\n\n可恢复\n\n# Kafka特点\n\nKakfa是一个分布式流处理平台，特点是高性能、分布式、高吞吐，底层写消息是顺序写磁盘，因此写入和读取速度非常快。大部分用于大数据处理平台和日志处理，其出身的原因也是LinkIn公司为了处理海量日志\n\n支持消息模型\n\n* 队列模型\n\n  同一个消息会被多个消费者一个个处理，不会重复处理\n\n* 发布订阅模型\n\n  同一个消息会被所有消费者消费，类似通知\n\n# 组件概念\n\nProducer：消息生产者\n\nConsumer：消息消费者\n\nBroker：实例，一般可以理解为服务器，一台服务器部署一个broker\n\nTopic：主题，消息是通过主题作为载体发送到队列中的\n\nPartition：分区，主题下的分区概念，分区是可以在多个broker中，消息是写到多个partition上，每个partition上的数据是有序的，但多个消息间是无序的，若要保证消息有序消费，则可以设置一个topic一个partition\n\n# 消费模型\n\ntopic下的多个partition可以分布在多个broker中，一般N个partition分布在N个broker上，或者N个partition分布在M个broker，尽量保证N<M，并且消费者数量<=N，多余的消费者是拿不到partition的\n\n## 副本机制\n\nKakfa提供副本机制来保证高可用，副本不用于消费，仅用来冗余数据。比如一个topic有N个partition，分布在N个broker上。一个partition可以有多个副本，副本间有一个leader和多个follower，读写都是在leader中，follower和leader会保持数据同步。假设topic有3个partition设置3个副本，则第一个partition的数据会复制到2、3上，最简单的策略就是2存储1的数据副本，3存储2的数据副本，当某个broker宕了，则保证另外的broker中有数据冗余，这就保证了消息能继续消费，保证高可用\n\n**存在情况** \n\n 假设leader所在的broker挂了，其他的follower还来不及同步消息，导致数据丢失，这种情况可以设置acks=all，表示当所有follower都收到该消息才算发送成功。\n\n\n\n\n\n\n\n","tags":["技术学习","消息队列","中间件"]},{"title":"工厂模式","url":"/2017/08/13/工厂模式/","content":"\n# 概述\n\n> 对比简单工厂模式集中工厂类生产，工厂模式将对象的创建交给相应的子类工厂，延迟创建，降低扩展对工厂接口的影响。这里有个要求就是工厂创建对象的细节不依赖于客户端。\n\n# 对象关系\n\n| 组成       | 关系                 | 作用                       |\n| ---------- | -------------------- | -------------------------- |\n| 抽象产品   | 具体产品的父类       | 产品的公共接口             |\n| 具体产品   | 抽象产品的子类       | 生产的具体产品             |\n| 抽象工厂   | 工厂抽象类           | 定义工厂的生产行为         |\n| 具体的工厂 | 工厂抽象类的具体实现 | 根据参数创建不同的具体产品 |\n\n<!--more-->\n\n# UML\n\n![工厂模式UML](/assets/blog_img/工厂模式.png)\n\n# 思路\n\n　　抽象对象保持不变，我们需要把工厂抽象化，让子类工厂去实现抽象工厂，提供对象返回，这么做下来，当我们需要哪个对象，就调用哪个子类工厂就行了。\n\n**产品抽象类**\n\n```java\nabstract class Product{\n\tString name;\n\tvoid show();\n}\n```\n\n**具体产品类**\n\n```java\nclass ProductA extends Product{\n\tpublic void show(){\n    //生产产品A；\n  }\n}\n\nclass ProductB extends Product{\n\tpublic void show(){\n    //生产产品B；\n  }\n}\n```\n\n**工厂接口**\n\n```java\ninterface Factory {\n\tpublic Product getProduct();\n}\n```\n\n**A工厂**\n\n```java\npublic FactoryA implements Factory {\n\tpublic Product getProduct(){\n    return new ProductA();\n  }\n}\n```\n\n**B工厂**\n\n```java\npublic FactoryB implements Factory {\n\tpublic Product getProduct(){\n    return new ProductB();\n  }\n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n\tpublic static void main(String args[]){\n\t\tFactory fa = new FactoryA();\n    Product a = f.getProduct();\n    \n    Factory fb = new FactoryB();\n    Product b = f.getProduct();\n\t}\n}\n```\n\n> 优点：通过对应的工厂对象完成对象的创建，对比简单工厂模式将对象的创建从工厂类中解耦出来，易扩展。\n\n","tags":["技术学习","设计模式"]},{"title":"会话技术Cookie与Session","url":"/2017/08/06/会话技术Cookie与Session/","content":"\n### 序\n\n　　什么是会话？按照理解就是人与人之间建立的一次谈话称为会话，放到Web的语义下就是浏览器与服务端的一次数据交互。我们知道Http协议是无状态的，一次连接建立后，数据交互完就结束了，第二次请求如果浏览器的请求不带点标识，服务端是无从知道是哪个客户发消息来，这也就引出我们的主题，Web的会话跟踪技术—Cookie与Session。\n\n### Cookie\n\n　　Cookie意为饼干，是一种客户端技术，当浏览器访问服务端时，服务端可以向响应Cookie中写入想要的内容，客户端就会保留相应的Cookie内容，在其后的请求中都会带上相应的内容，也就可以带上我们的用户标识。\n\n#### 常见方法\n\n- public Cookie(String name,String value)\n- setValue与getValue方法\n- setMaxAge与getMaxAge方法\n- setPath与getPath方法\n- setDomain与getDomain方法\n- getName方法\n\n#### 不可跨域名\n\n　　Cookie是不能跨域名的，也就是a网站的Cookie是不能发到b网站去的。\n\n#### 有效时间\n\n　　使用setMaxAge来设置过期时间，如果是整数，则表示在MaxAge秒前有效，会写入磁盘；如果是负数，则表明Cookie是临时的，在浏览器关闭前是有效的。\n\n#### 没有修改和删除功能\n\n　　修改就是用新值去覆盖旧值。\n\n#### 域名\n\n　　domain属性决定了Cookie的域名，规定为\".域名\"。\n\n### Session\n\n　　是一种服务端技术，服务端会记录当前用户的相关信息，返回一个sessionId给客户端，那么下个请求就以sessionId唯一关联当前用户身份信息。\n\n#### 常见方法 \n\n- long getCreationTime();【获取Session被创建时间】\n- **String getId();【获取Session的id】**\n- long getLastAccessedTime();【返回Session最后活跃的时间】\n- ServletContext getServletContext();【获取ServletContext对象】\n- **void setMaxInactiveInterval(int var1);【设置Session超时时间】**\n- **int getMaxInactiveInterval();【获取Session超时时间】**\n- **Object getAttribute(String var1);【获取Session属性**】\n- Enumeration getAttributeNames();【获取Session所有的属性名】\n- **void setAttribute(String var1, Object var2);【设置Session属性】**\n- **void removeAttribute(String var1);【移除Session属性】**\n- **void invalidate();【销毁该Session】**\n- boolean isNew();【该Session是否为新的】\n\n#### 生命周期与有效期 \n\n　　用户首次访问服务端servlet则会创建session对象。只要用户持续访问，服务端都会更新session的最后访问时间，而为了防止内存溢出，会把长时间没有访问的session干掉。默认的超时时间是30min，可以修改。","tags":["技术学习","Web"]},{"title":"抽象工厂模式","url":"/2017/07/21/抽象工厂模式/","content":"\n# 概述\n\n> 相比工厂模式，抽象工厂可以生产多类产品。抽象出产品类，比如电视类、空调类两类别产品，具体的产品子类对应子品牌，如海尔的电视，三星的电视或海尔的空调，三星的空调。工厂具体类主要包含需要生产的产品的组合，需要组合时只需扩展一个新的工厂具体类。\n\n<!--more-->\n\n# UML\n\n> ![UML图](/assets/blog_img/抽象工厂模式.png)\n\n> 缺点：当添加新的产品时，需要修改抽象工厂的接口，其子类都需要修改。\n\n# 思路\n\n　　怎么在一个工厂里组合生产多种产品呢？首先将多种类型的产品抽象化，创建对应产品的实现，创建顶层工厂抽象定义多种产品类族的工厂的抽象方法，这样顶层就决定了多种类族产品的组合，具体的产品有具体的抽象工厂。最终的效果就是我们能通过对应工厂获得对应的各种产品类\n\n**抽象产品类别**\n\n```java\nabstract class ProductCatoryA{\n\tvoid show();\n}\n\nabstract class ProductCatoryB{\n\tvoid catch();\n}\n```\n\n**具体产品**\n\n```java\nclass ProductConcreteAa extends ProductCatoryA{\n\tpublic void show(){\n    //生产类别A的具体产品品牌a；\n  }\n}\n\nclass ProductConcreteAb extends ProductCatoryA{\n\tpublic void show(){\n    //生产类别A的具体产品品牌b；\n  }\n}\n\nclass ProductConcreteBa extends ProductCatoryA{\n\tpublic void catch(){\n    //生产类别B的具体产品品牌b；\n  }\n}\n\nclass ProductConcreteBb extends ProductCatoryA{\n\tpublic void catch(){\n    //生产类别B的具体产品品牌b；\n  }\n}\n```\n\n**抽象工厂**\n\n```java\nabstract Factory {\n\tpublic ProductCatoryA makeCatoryA();\n  public ProductCatoryB makeCatoryB();\n}\n```\n\n**A工厂**\n\n```java\npublic FactoryA implements Factory {\n\tpublic ProductCatoryA makeCatoryA(){\n    return new ProductConcreteAa();\n  }\n  \n  public ProductCatoryB makeCatoryB(){\n    return new ProductConcreteBa();\n  }\n}\n```\n\n**B工厂**\n\n```java\npublic FactoryB implements Factory {\n\tpublic ProductCatoryA makeCatoryA(){\n    return new ProductConcreteAb();\n  }\n  \n  public ProductCatoryB makeCatoryB(){\n    return new ProductConcreteBb();\n  }\n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n\tpublic static void main(String args[]){\n\t\tFactory fa = new FactoryA();\n    ProductCatoryA a = fa.makeCatoryA();\n    ProductCatoryB b = fa.makeCatoryB();\n\n\n    Factory fb = new FactoryB();\n    ProductCatoryA aa = fb.makeCatoryA();\n    ProductCatoryB bb = fb.makeCatoryB();\n\n\t}\n}\n```\n\n# 总结\n\n　　可以看出来如果我们要加入新的产品族，我们就需要在顶层工厂加入新的工厂方法，那么每个具体的工厂需要去实现新的产品的工厂方法，如果遇到需求变化大的情况，扩展起来比较麻烦，所以抽象工厂模式适合少变的场景","tags":["技术学习","设计模式"]},{"title":"简单工厂模式","url":"/2017/04/26/简单工厂模式/","content":"\n# 概述\n\n\n> 通过一个工厂类的静态方法根据需要生产需要的对象，客户端直接调用工厂类，而不需要知道创建的细节。\n\n# 对象关系\n\n| 组成     | 关系           | 作用                       |\n| -------- | -------------- | -------------------------- |\n| 抽象产品 | 具体产品的父类 | 产品的公共接口             |\n| 具体产品 | 抽象产品的子类 | 生产的具体产品             |\n| 工厂     | 被客户端调用   | 根据参数创建不同的具体产品 |\n\n<!--more-->\n\n# UML\n\n![UML图](/assets/img/简单工程模式UML.png)\n\n****\n\n# 思路\n\n　　该模式的思路，首先定义一个抽象对象，定义相关的抽象方法，子对象通过继承实现抽象方法，实现工厂类，在工厂类提供一个静态对外调用，定义创建对象对应的参数，然后根据参数条件创建对应对象。\n\n**产品抽象类**\n\n```java\nabstract class Product{\n\tString name;\n\tvoid show();\n}\n```\n\n**具体产品类**\n\n```java\nclass ProductA extends Product{\n\tpublic void show(){\n    //生产产品A；\n  }\n}\n\nclass ProductB extends Product{\n\tpublic void show(){\n    //生产产品B；\n  }\n}\n```\n\n**工厂类**\n\n```java\nclass Factory {\n\tpublic static Product make(String type){\n\t\tswitch(type){\n\t\t\tcase \"A\":\n\t\t\t\treturn new ProductA();\n\t\t\tcase \"B\":\n\t\t\t\treturn new ProductB();\n      default:\n        return null;\n\t\t}\n\t}\n}\n```\n\n**客户端**\n\n```java\npublic class Client{\n\tpublic static void main(String args[]){\n\t\tFactory f = new Factory;\n    f.make(\"A\").show();\n    f.make(\"B\").show();\n\t}\n}\n```\n\n> 缺点：当需要添加或修改产品时，需要修改工厂类的逻辑，当类的数量多时，不容易维护。\n\n# 总结\n\n　　使用简单工厂模式创建对象，所有创建对象的逻辑都放在了工厂静态方法内，客户端传入对应的对象类型或者参数来让工厂输出对象，缺点就是所有的创建逻辑都在工厂方法内导致以后如果扩展新对象需要修改工厂方法，当对象增多之后，不容易维护。","tags":["技术学习","设计模式"]},{"title":"count的用法","url":"/2017/02/17/count的用法/","content":"\n**count(*)、count(id)、count(1)、count(字段)的区别，针对MySQL**\n\ncount(id)，InnoDB会遍历整张表，把每行的id取出来，返回给server层，判断不为空，按行累计。\n\ncount(1)，InnoDB会遍历整张表，每行放数字1进去，返回给server层，判断不为空，按行累计。\n\ncount(字段)\n\n* 如果字段定义为not null，一行行取出这个字段，判断不能为null，按行累加。\n* 如果字段定位为null，那么取的时候需要判断一下，不为null才累加。\n\ncount(*)，不会取全部字段，因为肯定不是null，直接按行累加。\n\n> 效率：count(字段)<count(主键id)<count(1)≈count(*)。尽量使用count(\\*)","tags":["技术学习","数据库"]},{"title":"单例模式","url":"/2017/02/16/单例模式/","content":"> 只有一个实例，类只创建一个对象，这个类提供一种访问其唯一对象的方式。\n\n懒汉式：只有实例用到的时候才会去加载，加载时判断是否生成实例，没有就立刻创建并返回，有则返回已有的唯一实例。\n\n```java\npublic class LazySingleton{\n\t\n\tprivate static LazySingleton instance;\n\t\n\tprivate LazySingleton();\n\t\n\tpublic static LazySingleton getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance = new LazySingleton();\t\n\t\t}\t\n\t\treturn instance;\n\t}\n\n}\n```\n\n<!--more-->\n\n饿汉式：实例在需要使用之前已经加载好了，用空间换取时间。\n\n```java\npublic class HungrySingleton{\n\n\tprivate static HungrySingleton instance = new HungrySingleton();\n\t\n\tprivate HungrySingleton();\n\t\n\tpublic static HungrySingleton getInstance(){\n\t\treturn instance;\n\t}\n\n}\n```\n\n双重检锁：保证线程安全。\n\n```java\npublic class DoubleLockSingleton{\n\n\tprivate volatile static DoubleLockSingleton instance ;\n\t\n\tprivate DoubleLockSingleton();\n\t\n\tpublic static DoubleLockSingleton getInstance(){\n\t\tif(instance==null){\n\t\t\t//保证只有一条线程能创建\n\t\t\tsynchronized(DoubleLockSingleton.class){\n\t\t\t\tif(instance==null){\n\t\t\t\t\tinstance=new \tDoubleLockSingleton();\n\t\t\t\t\t//jvm字节码指令分3步\n\t\t\t\t\t/*\n\t\t\t\t\t\t1、创建引用\n\t\t\t\t\t\t2、在堆上分配内存空间\n\t\t\t\t\t\t3、创建实例，引用与实例进行关联\n\t\t\t\t\t\t由于jvm的字节码执行时会根据需要进行优化，无法保证2和3的顺序，有可能引用返回的实例是空对象，因此加入volatile保证jvm字节码执行的有序性。\n\t\t\t\t\t*/\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\n}\n```\n\n静态内部类生成单例：当需要用到单例时，jvm会调用静态内部类的加载，并初始化该实例，jvm能保证只初始化一次，因此是线程安全的。\n\n```java\npublic class Singleton{\n  \n\tprivate Singleton(){}\n\t\n\tprivate static class SingletonHolder{\n\t\tprivate static final Singleton INSTANCE = new Singleton();\t\n\t}\n\t\n\tpublic Singleton getInstance(){\n\t\tretrun SingletonHolder.INSTANCE;\t\n\t}\n\n}\n```\n\n\n\n\n\n\n\n","tags":["技术学习","设计模式"]}]